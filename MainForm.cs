using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net.Sockets;

using LiveCharts;
using LiveCharts.WinForms;
using LiveCharts.Wpf;
using LiveCharts.Configurations;
using LiveCharts.Defaults;
using LiveCharts.Geared;
using System.Linq;
using System.Collections.Generic;

/** SEIZURE FILTER EEG PROGRAM 
 * Started by Dominic DiCarlo September 2018 
 * Edited by Tuan Pham December 2018 
    + REQUIREMENTS: 

            This program requires communication with OpenViBE acquisition software
        as well as designer software.That software can be obtained from
        Brain Products, and is found on the flash drive Towle lab
        received from them.

    + SUMMARY OF PURPOSE:                                                                                           
                                                                                                                      ▲         
            This program reads in data from a TCP server generated by OpenViBE Designer                             DANGER  
        For the acquisition, it takes in the data given at 512 Hz signal delivered in 4-sample                -------------------- danger upper bound  
        chunks. The root-mean-square (RMS) of a certain length of data is calculated like a                           ▲  
        sliding RMS function. The short-time Fourier Transform (STFT) of a certain length of data is               WARNING  
        also obtained to calculate the spectral of the signal, as well as the total band power                        ▼  
        of a certain frequency band (limited band power or LBP).                                              -------------------- warning upper bound  
                                                                                                                      ▲  
            The program also evaluates the alarm level of both RMS and LBP. If the RMS (or LBP)                     NORMAL   
        approaches certain upper or lower bounds, the graphical interface of the program will                         ▼  
        change the color of a bar to signify this, the default choice is from green (normal) to               -------------------- warning lower bound  
        yellow/gold (warning), to red (danger). Right now, the upper and lower bounds of these                        ▲  
        ranges has been arbitrarily decided. To use this program for the visual prosthesis, these                  WARNING   
        values will either have to be pre-determined or determined after experimentation has begun.                   ▼  
        We must decide whether to err on the side of safety or risk.                                          -------------------- danger lower bound  
                                                                                                                    DANGER   
                                                                                                                      ▼  

    + CONNECTION AND SETUP WITH THE OPENVIBE SOFTWARE: 

        1)  Connect the V-Amplifier to the computer and install any drivers
            you may be prompted to. The Brain Products usb will also install some drivers
            to your PC; these are needed for the V-Amp (supposedly)

        2)  Open OpenViBE Acquisition Server. Select V-Amp/Fast Amp from the Driver drop
            down menu. Adjust drift tolerance to 2.00 ms or lower from the Preferences button.
            Set "Sample count per sent block" to 4.

        3)  Open OpenViBE Designer. If this is your first time, select
            an "Acquisition Client" box from the folder "Acquisition and network IO".
            connect this to a "Temporal filter" box from '"Signal Processing"->"Temporal Filtering"'.
            Connect the "Temporal filter" box to a "Signal display" box and a "Matrix sender" box.

            NOTE #1 : Assure the "Matrix sender" box has TCP port "1234". You can check this by
            double clicking it, and seeing the TCP port. 

            NOTE #2: Assure the "Acquisition client" box has the same acquisition server
            port as the Connection port number on OpenViBE Acquisition Server. You can check the box
            by double clicking it, and the actual Acquisition Server right on the front of the program

            All the program really needs from designer is the "Matrix Sender", as this is what it reads.
            Feel free to adjust the Temporal Filter to your exact frequency needs,
            as well as adjust the signal display parameters for your needs. 

            You can save your settings in OpenViBE Designer as a config file. Simply
            click Save As at the top or Save. 

        4)  Hit Start at the top of Visual Studio, or run this program in the packaged way
            you have decided. Then, hit the play arrow on top of OpenViBE designer. 
            Voila! The program should be running. If not, run through these steps again
            and ensure you have done everything right.


    + FUTURE CONSIDERTIONS:

        1)  It would be nice to be able to change the upper and lower bounds of the RMS
            safety window from the GUI. This change could be easily made

        2)  Adding more channels and the ability to manage multiple samples from the stream at once.
            - There is room in the logic to do this, and it would just look like more of the same code. 
            We would need to decide how many channels we want to look at in the first place.

        3)  Adding in EEG visualization
            - OpenViBE supplies this in the mean time, but creating our own EEG viewer
            would be optimal as we can modify it to suit our needs.
    
        4)  Writing the CSV of values from the experiment in a path that will work for all systems
            - Right now, the CSV path has to be edited in the code
            so that it works on other systems.What would be more ideal
            would be the user selecting a path before the program begins.
            This would be easy to program.

    The logic of everything is simplified right now to only work with one
    channel and one sample at a time.This is then a skeleton for more work
    depending on how much data you want to use.                                                                             
                                                                                                    
*/

namespace seizure_filter
{
    /* MainForm first prompts for input then streamed EEG related data
     * 
     * The outline of the application is: 
     * Prompt.ConfigPrompt -> Prompt.MainPrompt -> MainForm.APP_INP_PRM = Prompt.Result -> MainForm.DrawAndReport 
     * 
     * - Prompt.ConfigPrompt: to either create a new configuration or to create a new configuration set up 
     * - Prompt.MainPrompt: to edit an existing configuration or edit from a default one to create a new set up 
     * - Then `MainForm` uses the resulting configuration to plot the streaming data in `DrawAndReport` 
     */
    public partial class MainForm : Form
    {
        #region MainForm attributes/properties 
        /* Application input parameters - from Prompt ouput or an existing configuration file 
         * - This is necessary to set up neccessary parameters for 
         * (a) Reading streaming data from the correct port, 
         * (b) Data calculations, and
         * (c) Visualization options 
         * - There are three options from Prompt:  
         * (1) Create a completely new configuration file, with parameters loaded from 
         *      a default configuration file (`_config_file.txt`: please don't modify this regularly),
         *      then save the configuration file 
         * (2) Load an existing configuration, and modify the configutation in Prompt.
         *      Then opt to either save it as a new file or overwrite it. 
         *      The warning of overwriting is not yet implemented so be careful
         * (3) Load an existing configutation, then start MainForm to plot, 
         *      meaning Prompt would not appear to modify parameters.
         *      The warning for loading an non-existing file is not yet implemented 
         * The general idea is: when one first starts, option (1) is prefered to create an initial configuration 
         *                      then later on, option (2) is preferred to start modifying the parameters (for example: alarm thresholds) 
         *                      once configuration is settled, option (3) is prefered, 
         *                      and occasional going back to (2) for small modifications
         */
        private ApplicationInputParameters APP_INP_PRM;
        /* Thread to run DrawAndReport 
         */
        private Thread logic_thread;

        /* Array of calculators
         * + STFTCalcs: Array of Short-time Fourier transform calcultors, 
         *              contains information and calculation on spectral analysis, 
         *              and spectral alarm rates
         * + RMSCalcs:  Array of Root-mean-square calculators, and the queue of current data      
         *               contains information and calculation on current data and RMS, 
         *               and RMS alarm rates
         */
        public STFTCalculator[] STFTCalcs;
        public RMSCalculator[] RMSCalcs;
        /* Array of series to pass on values to be recognized by the plotting module/library 
         * Briefly, `ChannelSeries`, `RMSSeries`, `LBPSeries` are Time Series (meaning x_axis is time) 
         * While `STFTSeries` X axis is Frequency 
         * The `RMSAlarmSeries` and `LBPAlarmSeries` are also Time Series, but at a slower update rate. 
         * + ChannelSeries:     Channel values, and their difference; 
         *                      - For now implemented only 2 channels + their difference 
         *                      - However, it is possible to generalize, as long as do not include pair difference
         *                      - Generalization with pairwise difference plotting might mean creating a separate plot pannel 
         * + RMSSeries:         Root-mean-square values of the channels 
         *                      - Sliding RMS window, with specified length in the prompt 
         * + STFTSeries:        Short-time Fourier transform values of the (normalized) channels 
         *                      - Channel data are normalized by mean and variance before doing STFT 
         *                      - There's also an option to use single tapers to the normalized data before STFT 
         * + LBPSeries:         Limited band power of the channels
         *                      - Sum of squares of the magnitude of STFT, with the option to scale to Fs and applied taper (refer to the implementation )
         *                      - The frequency band is specified by prompt 
         * + RMSAlarmSeries:    RMS alarm rate over 3 alarm levels (Normal=0, Warning=1, Danger=2) 
         *                      - The rate is updated for every particular duration of time (for example, every 2s) then reset 
         *                      - The array is length of 3 (n_lvls), each of which is the alarm rate sum of all the channels 
         *                      - The duration is specified in prompt 
         * + LBPAlarmSeries:    LBP alarm rate over 3 alarm levels (Normal=0, Warning=1, Danger=2) 
         *                      - Similarly set up like RMS alarm rate 
         *                      - The array is length of 3 (n_lvls), each of which is the alarm rate sum of all the channels 
         *                      - The duration is specified separately from RMSAlarmSeries 
         */
        public GearedValues<ObservablePoint>[] ChannelSeries;
        public GearedValues<ObservablePoint>[] RMSSeries;
        public GearedValues<ObservablePoint>[] STFTSeries;
        public GearedValues<ObservablePoint>[] LBPSeries;
        public GearedValues<ObservablePoint>[] RMSAlarmSeries;
        public GearedValues<ObservablePoint>[] LBPAlarmSeries;
        #endregion MainForm attributes/properties 

        #region Constructor and Initialization 

        /* MainForm initialization 
         * + LAYOUT: 
         *      (1) Initialize the components of the form (the set up of the form),
         *          - Refer to autogenerated "MainForm.Designer.cs" for more information 
         *              about the different components in th UI 
         *      (2) Prompting for parameter input,
         *          - Refer to "Prompt.cs" and "ApplicationInputParameters.cs" for more information 
         *      (3) Initialize Calculators, Plotting Series and Plotting Setup, 
         *          - Refer to "---Calculator.cs" files for more information about Calculators set ups 
         *          - Refer to online documentation of the plotting module `LIVECHARTS` 
         *              for set up of Plotting Series and Plotting Setup 
         *      (4) Load the form to start streaming data once everything is set
         *          - The main layout is in `DrawAndReport` method
         * + REQUIREMENTS: 
         *      - OpenVibe_Designer:    + For designing the communication set up with 
         *                                  `OpenVibe_Acquisition` (or with sinusoidal simulator) to this program. 
         *                              + In short, this is the middle man/woman/human/stuff.  
         *      - OpenVibe_Acquisition: + For connecting with EEG set up with `OpenVibe_Designer` setup.
         *                              + This would not be necessary when running sinusoidal simulator in `OpenVibe_Designer`.
         *      - LiveCharts:           + Plotting module/library in this, a lot of the code is 
         *                                  about setting up configuration to use this module. 
         *                                  Hence, these details can be ignored during migration to another language 
         *                              + LiveCharts.Geared is also used here because it is optimized for 
         *                                  faster plotting of streaming data. It is however commerical. 
         *                                  However, have not paid for it yet. Not sure why. My guess is 
         *                                  that just the `LiveCharts.Geared.Wpf` is commerical, and I'm using 
         *                                  `LiveCharts.Geard` mainly for `WindowsForm`, which might not commerical.
         *                                  I was able to install it from NuGet, so have been using it still. 
         *      - Accord.Math:          + For Fourier Transform 
         * + GENERAL INPUT: 
         *      - Streaming data from EEG recording channels, supposedly 
         *      - Requires correct set up from the OpenVibe Designer and Acquisition 
         *      - Then need an `APP_INP_PRM` object from `Prompt` and/or an existing configuration file to create 
         *          (APP_INP_PRM: details of configuration for reading data, calculations and plotting)
         * + GENERAL OUTPUT: 
         *      (1) Occipital EEG data 
         *              @ `ChannelSeries` and `channel_plots`
         *      (2) Their difference
         *              @ `ChannelSeries` and `channel_plots`
         *      (3) Root mean square (RMS), 
         *              @ `RMSSeries` and `rms_plots`
         *      (4) Short-time Fourier transform (STFT), 
         *              @ `STFTSeries` and `spectral_plots`
         *      (5) Limited band power (LBP), 
         *              @ `LBPSeries` and `limbandpow_plots`   
         *      (6) Flashing alarm for every calculation of RMS for each channel
         *              @ `rms_alarm1` and `rms_alarm2`
         *      (7) Flashing alarm for every calculation of LBP for each channel
         *              @ `lbp_alarm1` and `lbp_alarm2`
         *      (8) Alarm rates (for a certain period of time, sum of all channels) for 3 alarm levels of RMS 
         *              @ `RMSAlarmSeries` and `rms_alarm_plots`
         *      (9) Alarm rates (for a certain period of time, sum of all channels) for 3 alarm levels of LBP
         *              @ `LBPAlarmSeries` and `lbp_alarm_plots`
         *      
         */
        public MainForm()
        {
            InitializeComponent();
            using (Prompt prompt = new Prompt(title: "ENTER THE INPUT PARAMETERS", caption: "Input parameters"))
            {
                APP_INP_PRM = prompt.Result;
            }
            InitializeCalculators();
            InitializePlotSeries();
            InitializePlotSetUp();
            Load += MainForm_Load;
        }

        /* MainForm_Load: creating a thread to start `DrawAndReport`
         * I believe there are many improvements that can be made to this 
         * for allocating resources to calculating and plotting 
         * I'm not really familiar with threading, unfortunately. 
         */
        private void MainForm_Load(object sender, EventArgs e)
        {
            logic_thread = new Thread(DrawAndReport);
            logic_thread.Start();
        }

        /* InitializeCalculators: initialize calculators for storing streaming channel data, RMS and spectral calculations 
         * Refer to "RMSCalculator.cs" and "STFTCalculator" for more information 
         */
        private void InitializeCalculators()
        {
            int nchan = APP_INP_PRM.nchan;
            STFTCalcs = new STFTCalculator[nchan];
            RMSCalcs = new RMSCalculator[nchan];
            for (int i = 0; i < nchan; i++)
            {
                RMSCalcs[i] = new RMSCalculator(
                    nmax_queue_total: APP_INP_PRM.nmax_queue_total,
                    n_lvls: APP_INP_PRM.n_lvls);

                STFTCalcs[i] = new STFTCalculator(
                    Fs: APP_INP_PRM.Fs,
                    n_epoch: APP_INP_PRM.n_epoch,
                    n_skip: APP_INP_PRM.n_skip,
                    n_lvls: APP_INP_PRM.n_lvls,
                    BPFR: new double[] { APP_INP_PRM.f_bandpower_lower, APP_INP_PRM.f_bandpower_upper },
                    win_type: APP_INP_PRM.window_type,
                    scaling_psd: APP_INP_PRM.scaling_psd,
                    file_prefix: APP_INP_PRM.output_file_name,
                    saving_option: APP_INP_PRM.stft_saving_option);

            }
        }

        /* InitializePlotSeries: initialize the series (`__Series objects) to "communicate" with the CartesianCharts objects (`__plots` objects in the "MainForm.Designer.cs") 
         * Much of this can be ignored when migrating to another language. 
         * A lot of this is sort of hard-coded sadly so, again, would not make much sense to migrate.
         * However, this can be improved if the channel difference data are plotted on another CartesianCharts object instead of in the same plot as in `channel_plots`
         * If that is done, much of the "design" choices can then be set in the configuration set up (saved in `APP_INP_PRM` and prompted by `Prompt`) 
         */
        private void InitializePlotSeries()
        {
            int nchan = APP_INP_PRM.nchan;

            // Mapper of ObservablePoint for plotting later on 
            var mapper = Mappers.Xy<ObservablePoint>().X(value => value.X).Y(value => value.Y);
            Charting.For<ObservablePoint>(mapper);

            // Here is where the limit happens, meaning could only plot 2 channels + 1 line series of their difference 
            // Plotting the difference in another CartesianChart in a more systematic way would enable this to 
            //      generalize to many more channels to be plot. However, the problem with labelling the pairwise difference 
            //      with more than a few channels would be hard, as that would be a combinatoral of 2 over N channels. 
            // The reason for 2 channels + 1 difference was to observe 2 occipital EEG channels supposedly during stimulation.
            //      Since stimulation would be on 1 side, the difference data would reflect the asymmetric seizure appearance were there to be any. 
            string[] legends = {"Ch " + APP_INP_PRM.chan_idx2plt[0],
                                "Ch " + APP_INP_PRM.chan_idx2plt[1],
                                "Ch " + APP_INP_PRM.chan_idx2plt[0] + " - Ch " + APP_INP_PRM.chan_idx2plt[1]};
            System.Windows.Media.DoubleCollection[] dashed_style =
            {
                new System.Windows.Media.DoubleCollection(new double[] { 1,0 }),  // solid for first incoming channel 
                new System.Windows.Media.DoubleCollection(new double[] { 5,2 }),  // dashed for second 
                new System.Windows.Media.DoubleCollection(new double[] { 1,0 })   // solid for their difference 
            };
            System.Windows.Media.SolidColorBrush[] ch_brushes =
            {
                 System.Windows.Media.Brushes.Black,
                 System.Windows.Media.Brushes.Gray,
                 System.Windows.Media.Brushes.Red
            };

            // `ChannelSeries` setup then add to `chanel_plots` 
            ChannelSeries = new GearedValues<ObservablePoint>[nchan + 1];
            for (int idx_obs = 0; idx_obs < nchan + 1; idx_obs++)
            {
                ChannelSeries[idx_obs] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality // needed for Geared to perform well 
                };
                channel_plots.Series.Add(new GLineSeries
                {
                    Values = ChannelSeries[idx_obs],
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    StrokeThickness = 2,
                    Fill = System.Windows.Media.Brushes.Transparent,
                    Stroke = ch_brushes[idx_obs],
                    Title = legends[idx_obs] + " \t"
                });
            }

            // `RMSSeries` setup then add to `rms_plots`
            // `STFTSeries` setup then add to `spectral_plots`
            // `LBPSeries` setup tthen add to `limbandpow_plots`
            RMSSeries = new GearedValues<ObservablePoint>[nchan];
            STFTSeries = new GearedValues<ObservablePoint>[nchan];
            LBPSeries = new GearedValues<ObservablePoint>[nchan];
            for (int ichan = 0; ichan < nchan; ichan++)
            {
                RMSSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                rms_plots.Series.Add(new GLineSeries
                {
                    Values = RMSSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = new System.Windows.Media.SolidColorBrush { Color = System.Windows.Media.Color.FromArgb(50, 128, 89, 123) },
                    Title = legends[ichan] + " RMS",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });

                STFTSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                spectral_plots.Series.Add(new GLineSeries
                {
                    Values = STFTSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = System.Windows.Media.Brushes.Transparent,
                    Title = legends[ichan] + " STFT",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });

                LBPSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                limbandpow_plots.Series.Add(new GLineSeries
                {
                    Values = LBPSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = new System.Windows.Media.SolidColorBrush { Color = System.Windows.Media.Color.FromArgb(50, 100, 120, 200) },
                    Title = legends[ichan] + " BP",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });
            }

            // Alarm levels are set to 3 here, 
            // + Normal = 0 
            // + Warning = 1
            // + Danger = 2
            // There's a way to generalize this, but I though that 3 levels are 
            //      probably quite sufficient to look at already since there would be 
            //      3 colors to look at. More than that, I would argue could be 
            //      overwhelming and distracting.
            // Regardless, generalization would mean having these as options back in "ApplicationInputParameters.cs" and 
            //      prompt for such configurations in `Prompt`. 
            int n_lvls = APP_INP_PRM.n_lvls;
            System.Windows.Media.SolidColorBrush[] brushes =
            {
                ApplicationInputParameters.ColorToBrush(APP_INP_PRM.normal_color),
                ApplicationInputParameters.ColorToBrush(APP_INP_PRM.warning_color),
                ApplicationInputParameters.ColorToBrush(APP_INP_PRM.danger_color)
            };
            string[] alarm_lvl_str = { "Normal", "Warning", "Danger" };

            // There are 2 ways to plot: either 
            // (1) area-stack them on top of each other, with Normal bottom, Warning middle then Danger on top; or
            // (2) just plot them as lines for easily inspection of alarm rate trend 
            //      since stacking might sometimes be hard to tell the trend 
            // There's an option in LiveCharts to plot StackedArea explicitly but I chose to manually implement it 
            //      by doing the LineSeries instead by basically adding them up for uniformity of code 
            //      refer to `RMSCalculator.Cumulative_From_Lower_Level` 
            //      or `STFTCalculator.Cumulative_From_Lower_Level` for details.
            // Hence, to maintain that uniformity in the area-stack implementation, 
            //      the order of the series matters due to overlaying effects of series added later. 
            int i_start, i_bound, i_incr, i_sign_cond;
            double stroke_thickness, alarm_rate_opacity;
            System.Windows.Media.Geometry point_geom = DefaultGeometries.None;
            if (APP_INP_PRM.alarm_rate_plt_stack) // stack them up 
            {
                // equilvalent to `for (int i = n_lvls-1; i >= 0; i--)`   
                // meaning the Danger one gets added first, hence would be the one way in the back 
                // hence calling `Cumulative_From_Lower_Level` would be to make it higher but still maintain the right proportion
                // when taken into account all the levels. 
                i_start = n_lvls - 1;
                i_bound = -1;
                i_sign_cond = 1;
                i_incr = -1;

                stroke_thickness = 1.50;
                alarm_rate_opacity = 0.9;
            }
            else // regular line plot - which is the default 
            {
                // equilvalent to `for (int i = 0; i < n_lvls; i++)`
                i_start = 0;
                i_bound = n_lvls;
                i_sign_cond = -1;
                i_incr = +1;

                stroke_thickness = 4.5;
                alarm_rate_opacity = 0.0;
            }

            // `RMSAlarmSeries` setup then add to `rms_alarm_plots`
            // `LBPAlarmSeries` setup then add to `lbp_alarm_plots`
            RMSAlarmSeries = new GearedValues<ObservablePoint>[n_lvls];
            LBPAlarmSeries = new GearedValues<ObservablePoint>[n_lvls];
            for (int i = i_start; i.CompareTo(i_bound) == i_sign_cond; i += i_incr)
            {
                RMSAlarmSeries[i] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                rms_alarm_plots.Series.Add(new GLineSeries
                {
                    Values = RMSAlarmSeries[i],
                    StrokeThickness = stroke_thickness,
                    PointGeometry = point_geom,
                    PointForeground = brushes[i],
                    LineSmoothness = 1,
                    Fill = new System.Windows.Media.SolidColorBrush
                    {
                        Opacity = alarm_rate_opacity,
                        Color = brushes[i].Color
                    },
                    Stroke = brushes[i],
                    Title = alarm_lvl_str[i]
                });

                LBPAlarmSeries[i] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                lbp_alarm_plots.Series.Add(new GLineSeries
                {
                    Values = LBPAlarmSeries[i],
                    StrokeThickness = stroke_thickness,
                    PointGeometry = point_geom,
                    PointForeground = brushes[i],
                    LineSmoothness = 1,
                    Fill = new System.Windows.Media.SolidColorBrush
                    {
                        Opacity = alarm_rate_opacity,
                        Color = brushes[i].Color
                    },
                    Stroke = brushes[i],
                    Title = "\n" + alarm_lvl_str[i] + "\n" // to space the legend out a bit 
                });
            }
        }

        /* InitializePlotSetUp: initialize plot axes/legend setup options and maximize plotting performance  
         * Refer `PlotSetUpAndMaximizePerformance` for further descriptions
         * Much of this is manual, hence can be ignored while migrating to another language 
         */
        private void InitializePlotSetUp()
        {
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref channel_plots,
                axes_label: new Axes_Label(xlabel: "Time (s)", ylabel: "Voltage (uV)"),
                axes_limit: null,
                x_axis_merged: false,
                y_axis_merged: true,
                lgnd_loc: LegendLocation.Top);
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref rms_plots,
                axes_label: new Axes_Label(xlabel: "Time (s)", ylabel: "RMS (uV)"),
                axes_limit: null,
                x_axis_merged: false,
                y_axis_merged: true,
                lgnd_loc: LegendLocation.None);
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref spectral_plots,
                axes_label: new Axes_Label(xlabel: "Frequency (Hz)", ylabel: "FFT (AU)"),
                axes_limit: new Axes_Limit(xlim: new double[] { -0.1, 40 }, ylim: new double[] { 0, double.PositiveInfinity }));
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref limbandpow_plots,
                axes_label: new Axes_Label(xlabel: "Time (s)", ylabel: string.Format("Band power {0} - {1} Hz", APP_INP_PRM.f_bandpower_lower, APP_INP_PRM.f_bandpower_upper)),
                axes_limit: null,
                x_axis_merged: false,
                y_axis_merged: true);
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref rms_alarm_plots,
                axes_label: new Axes_Label(xlabel: "Time (s)", ylabel: "# of RMS alarms"));
            PlotSetUpAndMaximizePerformance(
                cart_chart: ref lbp_alarm_plots,
                axes_label: new Axes_Label(xlabel: "Time (s)", ylabel: "# of Spectral alarms"),
                axes_limit: null,
                x_axis_merged: false,
                y_axis_merged: false,
                lgnd_loc: LegendLocation.Left);

        }

        /* Axes_Label: struct for x and y axis labels 
         */
        private struct Axes_Label
        {
            public string xlabel, ylabel;
            public Axes_Label(string xlabel, string ylabel)
            {
                this.xlabel = xlabel;
                this.ylabel = ylabel;
            }
        }

        /* Axes_Limit: class for setting limits of axes 
         * Generally if any element is a DOUBLE.POSITIVE_INFINITY or NEGATIVE_INFINITY then the limit is not set
         * For example, + if xlim = {0, +INF} then always set the plot x-axis to have lowest bound as 0, 
         *              but upper bound will be set by LiveCharts automatically 
         *              + if xlim = {-INF, +INF} then LiveCharts will set the limit automatically,
         *              according to the plotted streamed data values 
         *              + and so on for other scenarios for both xlim and ylim. 
         */
        private class Axes_Limit
        {
            public double xlow, xhigh, ylow, yhigh;
            private readonly double[] xlim, ylim;
            public void Check_Limit_Validity(double[] inp)
            {
                if (inp.Length != 2)
                {
                    throw new System.ArgumentOutOfRangeException("The input limit range needs to be a double array of only 2 elements");
                }
                if (inp[0] >= inp[1] && !double.IsInfinity(inp[0]) && !double.IsInfinity(inp[1]))
                {
                    throw new System.ArgumentException(string.Format("The lower bound (1st element = {0}) needs to be smaller" +
                        " than the upper bound (2nd element = {1})", inp[0], inp[1]));
                }
            }
            public Axes_Limit(double[] xlim, double[] ylim)
            {
                this.xlim = xlim;
                this.ylim = ylim;
                xlow = xlim[0];
                xhigh = xlim[1];
                ylow = ylim[0];
                yhigh = ylim[1];
                Check_Limit_Validity(this.xlim);
                Check_Limit_Validity(this.ylim);
            }
        }

        /* PlotSetUpAndMaximizePerformance: setting the plot (CartesianChart objects) axes and legend options + maximize plotting performance 
         * + LAYOUT: 
         *      - Create axes and set options of labels, limits and merging for the main axes 
         *      - Create pseudo axes to obtain solid "edges" of the axes (refer to the code for details) 
         *      - Set location of the legend 
         *      - Maximize performance for plotting streaming data 
         * + INPUT: 
         *      - cart_chart:       the reference of the CartesianChart object to set these options 
         *      - axes_label:       Axes_Label object to set labels for x-axis and y-axis 
         *      - axes_limit:       Axes_Limit object to set limits for x-axis and y-axis 
         *                          default is "null", meaning not setting the limits manually 
         *      - x_axis_merged:    merge the x-tick values onto the axis to save space, refer to ref. (1) 
         *                          default is "false", meaning not merged
         *                          however, should set to "true" for the 3 middle time series plots
         *                          because the representation of the values could change the widths of 
         *                          the main plot, which could be misleading when trying to compare between 
         *                          the 3 time series plots in the middle. 
         *      - y_axis_merged:    merge the y-tick values onto the axis to save space, refer to ref. (1) 
         *                          default is "false", meaning not merged
         *                          however, should set to "true" for the 3 middle time series plots
         *                          because the representation of the values could change the widths of 
         *                          the main plot, which could be misleading when trying to compare between 
         *                          the 3 time series plots in the middle. 
         *      - lgnd_loc:         location of the legend in the plot, refer to ref. (1) 
         *                          only 5 options {"Bottom", "Top", "Right", "Left", "None"}
         *                          default is "LegendLocation.None"
         * + OUTPUT: 
         *      - NONE
         *      - Set up the options for axes and legend locations 
         *      - Then maximize plot performacne for streaming data, refer to ref. (2) 
         * + REFERENCE:
         *      (1) Axes set up:      https://lvcharts.net/App/examples/v1/wf/Axes
         *      (2) Performance tips: https://lvcharts.net/App/examples/v1/wf/Performance%20Tips
         */
        private void PlotSetUpAndMaximizePerformance(ref LiveCharts.WinForms.CartesianChart cart_chart,
                                                        Axes_Label axes_label,
                                                        Axes_Limit axes_limit = null,
                                                        bool x_axis_merged = false,
                                                        bool y_axis_merged = false,
                                                        LegendLocation lgnd_loc = LegendLocation.None)
        {
            // Axes options 
            string font_fam = "Microsoft Sans Serif";
            var axes_color = System.Windows.Media.Brushes.Gray;
            cart_chart.Font = new Font(font_fam, 12F);
            cart_chart.ForeColor = ApplicationInputParameters.BrushToColor(axes_color);

            cart_chart.AxisX.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 1, Stroke = axes_color, IsEnabled = false },
                FontSize = 20F,
                FontFamily = new System.Windows.Media.FontFamily(font_fam),
                Foreground = axes_color,
                Title = axes_label.xlabel,
                IsMerged = x_axis_merged
            });

            cart_chart.AxisY.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 1, Stroke = axes_color, IsEnabled = false },
                FontSize = 20F,
                FontFamily = new System.Windows.Media.FontFamily(font_fam),
                Foreground = axes_color,
                Title = axes_label.ylabel,
                IsMerged = y_axis_merged,

            });
            // Axes limit 
            if (axes_limit != null)
            {
                if (!double.IsInfinity(axes_limit.xlow)) { cart_chart.AxisX[0].MinValue = axes_limit.xlow; }
                if (!double.IsInfinity(axes_limit.xhigh)) { cart_chart.AxisX[0].MaxValue = axes_limit.xhigh; }

                if (!double.IsInfinity(axes_limit.ylow)) { cart_chart.AxisY[0].MinValue = axes_limit.ylow; }
                if (!double.IsInfinity(axes_limit.yhigh)) { cart_chart.AxisY[0].MaxValue = axes_limit.yhigh; }
            }

            // pseudo axes to display the axes more easily because hiding the axes grids also hides the actual axes edges 
            // hence needed these pseudo axes, which do not affect performance, as far as I know 
            cart_chart.AxisX.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 0.5, Step = 1, Stroke = axes_color },
                MinValue = 0,
                MaxValue = 0.5,
                FontSize = 0.5F,
                Foreground = System.Windows.Media.Brushes.Transparent
            });
            cart_chart.AxisY.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 0.5, Step = 1, Stroke = axes_color },
                MinValue = 0,
                MaxValue = 0.5,
                FontSize = 0.5F,
                Foreground = System.Windows.Media.Brushes.Transparent
            });

            // Legend location 
            cart_chart.LegendLocation = lgnd_loc;

            // Maximize plot performacne for streaming data, refer to ref. (2) 
            cart_chart.DisableAnimations = true;
            cart_chart.Hoverable = false;
            cart_chart.DataTooltip = null;
            cart_chart.Invalidate();

        }

        #endregion Constructor and Initialization 

        #region Helper functions 
        /* ReturnAlarmLevelAndColor: evaluate the alarm level of a value -> return the corresponding alarm color & level index  
 * + LAYOUT: 
 *      - There are 3 levels of alarm (Normal=0, Warning=1, Danger=2) 
 *      - For each of the range, there's a lower bound (L) and an upper bound (U) 
 *      - The requirement of the ranges ( refer to `ApplicationInputParameters.CheckForAlarmRange`) 
 *          danger_lower < warning_lower < warning_upper < danger_upper 
 *      - Return either of the 3 alarm levels and the corresponding color + index 
 *          * NORMAL:   anything within [warning_lower, warning_upper] 
 *          * WARNING:  anything out of that range, but still within [danger_lower, danger_upper] 
 *          * DANGER:   otherwise 
 * + INPUT: 
 *      - value:            the value being passed on to check, either an RMS or LBP value for example 
 *      - range_danger:     the range out of which would be considered DANGER
 *      - range_warning:    the range out of which, but still within `range_danger`, would be considered WARNING 
 * + OUTPUT: 
 *      - color_res:        color corresponding to the alarm level, e.g: RED (danger), YELLOW (warning), GREEN (normal) 
 *      - level_res:        level index corresponding to the alarm level, e.g: 2 (danger), 1 (warning), 0 (normal) 
 *      
 */
        private void ReturnAlarmLevelAndColor(double value, double[] range_danger, double[] range_warning,
                                                out Color color_res, out int level_res)
        {
            if (value < range_danger[0] | value > range_danger[1])
            {
                color_res = APP_INP_PRM.danger_color;
                level_res = 2;
            }
            else if (value < range_warning[0] | value > range_warning[1])
            {
                color_res = APP_INP_PRM.warning_color;
                level_res = 1;
            }
            else
            {
                color_res = APP_INP_PRM.normal_color;
                level_res = 0;
            }
        }

        /* ReturnRMSLevel: evaluate the alarm level of an RMS value -> return the corresponding alarm color & level index  
         * Refer to `ReturnAlarmLevelAndColor` for more details 
         */
        private void ReturnRMSLevel(double value, out Color color_res, out int level_res)
        {
            ReturnAlarmLevelAndColor(
                value: value,
                range_danger: new double[] { APP_INP_PRM.danger_rms_lowerbound, APP_INP_PRM.danger_rms_upperbound },
                range_warning: new double[] { APP_INP_PRM.warning_rms_lowerbound, APP_INP_PRM.warning_rms_upperbound },
                color_res: out color_res,
                level_res: out level_res);
        }

        /* ReturnLBPLevel: evaluate the alarm level of an LBP value -> return the corresponding alarm color & level index  
         * Refer to `ReturnAlarmLevelAndColor` for more details 
         */
        private void ReturnLBPLevel(double value, out Color color_res, out int level_res)
        {
            ReturnAlarmLevelAndColor(
                value: value,
                range_danger: new double[] { APP_INP_PRM.danger_lbp_lowerbound, APP_INP_PRM.danger_lbp_upperbound },
                range_warning: new double[] { APP_INP_PRM.warning_lbp_lowerbound, APP_INP_PRM.warning_lbp_upperbound },
                color_res: out color_res,
                level_res: out level_res);
        }

        /* Full_Deep_Copy: return a deep copy of a double array to avoid referencing just in case, for plotting stuff 
         */
        private double[] Full_Deep_Copy(double[] source)
        {
            double[] destination = new double[source.Length];
            Array.Copy(source, destination, source.Length);
            return destination;
        }
        #endregion Helper functions 

        #region Update functions for simple WF objects 

        /* UpdateTextBox: update the Text property of any TextBox object asynchronously 
         * + LAYOUT: 
         *      - Call BeginInvoke from the object if not yet called 
         *      - The main objective is to change Text of the object 
         * + INPUT: 
         *      - txtbx:        a TextBox object to modify the Text property of 
         *      - s:            the string that TextBox.Text would be 
         * + OUTPUT: 
         *      - None, the property Text of the TextBox object would be changed 
         */
        private void UpdateTextBox(TextBox txtbx, string s)
        {
            if (InvokeRequired)
            {
                txtbx.BeginInvoke(new Action<TextBox, string>(UpdateTextBox), new object[] { txtbx, s });
                return;
            }
            txtbx.Text = s;
        }

        /* UpdateLabel: update the Text property of any Label object asynchronously 
         * + LAYOUT: 
         *      - Call BeginInvoke from the object if not yet called 
         *      - The main objective is to change Text of the object 
         * + INPUT: 
         *      - lbl:          a TextBox object to modify the Text property of 
         *      - s:            the string that Label.Text would be 
         * + OUTPUT: 
         *      - None, the property Text of the Label object would be changed 
         */
        private void UpdateLabel(Label lbl, string s)
        {
            if (InvokeRequired)
            {
                lbl.BeginInvoke(new Action<Label, string>(UpdateLabel), new object[] { lbl, s });
                return;
            }
            lbl.Text = s;
        }

        /* UpdatePanelColor: add a colored rectangle to a Panel object, to represent real-time alarm color 
         * + LAYOUT: 
         *      - Call BeginInvoke from the object if not yet called 
         *      - The main objective is to first refresh the Panel to clear any existing children graphics 
         *      - Then add a filled rectangle with a given color 
         * + INPUT: 
         *      - pnl:          a Panel object to add the rectangle to 
         *      - c:            to color of the rectangle to be set 
         * + OUTPUT: 
         *      - None, there would appear a filled rectangle with color `c` in panel `pnl` 
         */
        private void UpdatePanelColor(Panel pnl, Color c)
        {
            if (InvokeRequired)
            {
                pnl.BeginInvoke(new Action<Panel, Color>(UpdatePanelColor), new object[] { pnl, c });
                return;
            }
            pnl.Refresh();
            pnl.CreateGraphics().FillRectangle(new SolidBrush(c), 0, 0, pnl.Width, pnl.Height);
        }

        /* UpdateInitialization: update initialization when the connection with OpenVibe is established 
         * + LAYOUT: 
         *      - Update the `log` with the welcome message from `APP_INP_PRM` 
         *      - Update the index/name of the channels for the alarm labels 
         *      - Update the labels reporting values of vertical gain and offset 
         * + INPUT: 
         *      - title_message:    The first message to appeare on the `log` textbox 
         * + OUTPUT: 
         *      - None, the `log` and appropriate labels would be updated before starting to read the data 
         */
        private void UpdateInitialization(string title_message)
        {
            // Update the `log` with the welcome message from `APP_INP_PRM` 
            UpdateTextBox(log, title_message + "\r\n" + APP_INP_PRM.WelcomeMessage);

            // Update the index/name of the channels for the alarm labels 
            UpdateLabel(chan_label1_rms_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[0]);
            UpdateLabel(chan_label2_rms_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[1]);
            UpdateLabel(chan_label1_spectral_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[0]);
            UpdateLabel(chan_label2_spectral_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[1]);

            // Update the labels reporting values of vertical gain and offset 
            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));

        }
        #endregion Update functions for simple WF objects 

        #region Update functions for the plots 
        /* UpdateTimeSeriesPlot: update the time series plots asynchronously 
         * + LAYOUT: 
         *      - Call BeginInvoke from the object if not yet called 
         *      - The main objective is to add on the next point(s) to plot 
         * + INPUT: 
         *      - refreshable:      the option to have a refreshable plot, 
         *                          "true"  ->  meaning the xlim would be updated only every `max_sec_plt` 
         *                          "false" ->  meaning xlim would be updated by LiveCharts automatically, 
         *                                      like a continuously streaming time series 
         *      - cart_chart:       the CartesianChart object to be updated by the time `series` object 
         *      - series:           the series arrays to be updated with `values` and `t`
         *      - t:                the time point to be added 
         *      - values:           the array of values to be added to `series`, 
         *                          needs to be of the same length as `series` 
         *      - display_gains:    array of display vertical gains to adjust to the `series` for displaying purposes
         *                          needs to be of the same length as `series`
         *      - display_offset:   a single vertical offset value to adjust the `series` for displaying purposes 
         *      - max_sec_plt:      maximum # seconds to plot to update the corresponding xlim of the plot 
         *                          the value is only needed for refereshable plot 
         *                          for a continuous plot, LiveCharts would update the xlim according to the size of a series element (like series[1])
         *      - max_pnt_plt:      maximum # points to plot (would basically be `Fs * max_sec_plt` but already set in `APP_INP_PRM`) 
         *                          needed to update the size of each series element (like series[1]) according to choice of `refreshable`
         *      * Recommendations:  for performance, I found that having a refreshable plot (refreshable=true)
         *                              and a small `max_sec_plt` is generally better because the Series objects would
         *                              be cleared every so often, instead of keeping a large amount of data every time
         *                          for plotting, if desire just the original non-offset no-gain data, as well as initial plotting to
         *                              determine the threshold of alarms do this: 
         *                              + display_gains   = new double[] {1,1..1} (of the correct length) 
         *                              + display_offset  = 0
         * + OUTPUT: 
         *      - None, the series elements would be updated with the next time point and value pairs
         *          then the plot would be updated as well, with some configurations as described in INPUT section 
         */
        private void UpdateTimeSeriesPlot(bool refreshable,
                                            LiveCharts.WinForms.CartesianChart cart_chart,
                                            GearedValues<ObservablePoint>[] series,
                                            double t,
                                            double[] values,
                                            double[] display_gains,
                                            double display_offset,
                                            double max_sec_plt,
                                            double max_pnt_plt)
        {
            if (InvokeRequired)
            {
                cart_chart.BeginInvoke(new Action<
                                            bool,
                                            LiveCharts.WinForms.CartesianChart,
                                            GearedValues<ObservablePoint>[],
                                            double,
                                            double[],
                                            double[],
                                            double,
                                            double,
                                            double>(UpdateTimeSeriesPlot),
                                                new object[] {
                                                    refreshable,
                                                    cart_chart,
                                                    series,
                                                    t,
                                                    values,
                                                    display_gains,
                                                    display_offset,
                                                    max_sec_plt,
                                                    max_pnt_plt
                                                    });
                return;
            }

            int n_values = series.Length;

            for (int i = 0; i < n_values; i++)
            {
                // Limiting the size of a series element like `series[i]` to not have so much in memory 
                // if this is a refreshable plot: clear the content and start a new one (most optimal for performance) 
                // if this is a continuous plot: just remove the end (meaning the size of the series element would stay the same after some point) 
                if (series[i].Count >= max_pnt_plt)
                {
                    if (refreshable) { series[i].Clear(); }
                    else { series[i].RemoveAt(0); }
                }
                // Add to the series element with the updated time point and the data point 
                // with desired offset and gain for displaying purposes 
                series[i].Add(new ObservablePoint(t, values[i] * display_gains[i] - display_offset * i));
            }

            if (refreshable)
            {
                // Update with appropriate x-lim if this is a refreshable plot 
                RefreshableAxisLimits(t, max_sec_plt, out double min_bound, out double max_bound);
                cart_chart.AxisX[0].MinValue = min_bound;
                cart_chart.AxisX[0].MaxValue = max_bound;
            }

        }
        /* UpdateSTFTPlot: update the Short time Fourier transform plot (spectral plot) 
         * + NOTE:
         *      - Since this is not a time series plot, but a frequency-magnitude plot, 
         *          I decided to write another function for it because frequency would 
         *          be the same throughout, just the magnitude vector would change 
         * + LAYOUT: 
         *      - Call BeginInvoke if not havent 
         *      - Clear the previous data in each STFT Series 
         *      - Then deep copy the frequency and magnitude vector into new arrays (applied for the time series as well) 
         *          * The need for deep copy instead of referencing is not clear 
         *          * But I found that it would not mess up with the plotting data somehow 
         *      - Then create a range to of ObservablePoint object to add to the STFTSeries 
         *          * LiveCharts documentation recommended adding a range for performance 
         *          purposes if possible (not done for the time series one because not as conveninent) 
         * + INPUT: NONE, but `STFTCalcs` would have to be updated before hand 
         * + OUPUT: NONE, but `STFTSeries` would be updated as a result of calling this function 
         */
        private void UpdateSTFTPlot()
        {
            if (InvokeRequired) { spectral_plots.BeginInvoke(new Action(UpdateSTFTPlot)); }
            for (int ichan = 0; ichan < APP_INP_PRM.nchan; ichan++)
            {
                int n_valid = STFTCalcs[ichan].n_valid;
                STFTSeries[ichan].Clear();

                ObservablePoint[] stft_new = new ObservablePoint[n_valid];
                double[] freq = Full_Deep_Copy(STFTCalcs[ichan].freq_vec);
                double[] mag = Full_Deep_Copy(STFTCalcs[ichan].mag_freq);

                for (int idat = 0; idat < n_valid; idat++)
                {
                    stft_new[idat] = new ObservablePoint(freq[idat], mag[idat]);
                }
                STFTSeries[ichan].AddRange(stft_new);
            }
        }

        /* RefreshableAxisLimits: return new x-lim for refreshable plots 
         * + LAYOUT: 
         *      - Return the new min, max for xlim according to the maximum duration to plot (in seconds) 
         *      - Usually it would stay constant for S=`max_sec_plt` and xlim = [S*i, S*(i+1)] for an arbitrary increasing integer i 
         *      - But after every S, the bounds would change 
         * + INPUT: 
         *      - t:            the current time point of the plot 
         *      - max_sec_plt:  maximum number of seconds to plot for a particular plot 
         * + OUTPUT: 
         *      - min_bound:    lower bound of the x-lim
         *      - max_bound:    upper bound of the x-lim 
         */
        private void RefreshableAxisLimits(double t, double max_sec_plt, out double min_bound, out double max_bound)
        {
            min_bound = (Math.Floor(t / max_sec_plt) * max_sec_plt);
            max_bound = (Math.Floor(t / max_sec_plt) + 1) * max_sec_plt;
        }
        #endregion Update functions for the plots 

        #region DrawAndReport function
        /* DrawAndReport: all the connecting and plotting happens here
        * + LAYOUT: 
        *      (1) Connect with the OpenVibe port
        *      (2) WHILE loop to start reading the stream: 
        *          (3) Reading data from stream as string and select valid data chunks 
        *          (4) FOR each sample position in the chunk
        *              (5) Read and store current data point 
        *              (6) Visualizing for `channel_plots`:  The current values of both channels and their difference
        *              (7) Visualizing for `rms_plots` and update the rms alarm panels 
        *              (8) Visualizing for `spectral_plots` and `limbandpow_plots`
        *              (9) Visualizing for the rms alarm rate plots
        *              (10) Visualizing for the lbp alarrm rate plots 
        *              (11) Update the clock time 
        *              (12) Saving the current data 
        * + COMMENTS:
        *   - CMT_MatSndr: About the data from Matrix Sender (mostly matters for step 2, 3) 
        *       * Data from the MatrixSender of OpenVibe are sent in as ASCII format
        *       * Each valid chunk contains `APP_INP_PRM.chunk_len` data points, separated by commas
        *         >>    chunk_len = nsamp_per_block * total_nchan
        *       * For example, nsamp_per_block = 4, total_nchan = 3, the incoming chunk would be like 
        *         >>    "ch0_data0, ch0_data1, ch0_data2, ch0_data3, ch1_data0,..., ch1_data3, ch2_data0,..., ch2_data3" 
        *       * However, the issues arise occasionally where, instead of sending the chunk like the above
        *         the chunks received would be more like either of these options, or a combination of them: 
        *         >>    "<some weird ridiculously huge number>, <another number>"
        *         >>    "," (just a comma) 
        *         >>    (multiple chunks in separatelines, with the ones at the middle are fine, but at the beginning and end are not), below is an example 
        *                ,-2.29187,-2.49954,-2.65903,-0.442686,-0.338287,-0.100214,0.24069,1.46986,1.73674,1.96931,2.09206
        *               0.379649,0.251692,0.114043,-0.0312935,-2.75817,-2.78887,-2.74761,-2.63572,0.637258,1.03329,1.37227,1.60612,2.05754,1.85949,1.53473,1.1533
        *               -0.182173,-0.336351,-0.49152,-0.645352,-2.45932,-2.22882,-1.95829,-1.66439,1.70264,1.65047,1.46087,1.16588,0.799423,0.548676,0.447469,0.500566
        *               -0.795534,-0.939817,-1.07605,-1.2022,-1.36529,-1.07935,-0.823884,-0.613926,0.813317,0.459312,0.159523,-0.0395465,0.670008,0.885749,1.06508,1.13554
        *               -1.31644,-1.41711,-1.50281,-1.57237,-0.461207,-0.373336,-0.353272,-0.399128,-0.107806,-0.0362826,0.161474,0.451498,1.05498,0.823341,0.482878,0.106773
        *               -1.62492,-1.65987,-1.67692,-1.6761,-0.504303,-0.657955,-0.845757,-1.05091,0.784691,1.10448,1.35562,1.49284,-0.220739,-0.427286,-0.472044,-0.356787
        *               -1.65772,-1.62243,-1.57112,-1.50498,-1.25531,-1.44082,-1.59058,-1.6901,1.48786,1.33388,1.04658,0.661787,-0.125287,0.148778,0.382097,0.50461
        *               -1.42546,-1.33421,-1.23311,-1.12416,-1.72838,-1.69861,-1.5987    
        *       * My solution for this is, before parsing the string to a double array, I would have to: 
        *         (a)   First, filter the lines by only choosing the ones that
        *               + Did not begin with just a comma 
        *               + And when split by a comma, the corresponding array would have length = APP_INP_PRM.chunk_len
        *         (b)   Secondly, if lines.Length == 1, then I would read it as it is, 
        *               if not, since the ridiculously large values usually appear on the first chunk, 
        *               I chose not to read it at all. Just read from lines[1] to lines[lines.Length-1]
        *   - CMT_SavOut: About saving to output file (before step 2; then step 12)
        *       * Notes: 
        *         (a)   Although the data are saved at this step, as will be noted later one, these data 
        *               would not be the most accurate data due to connection with OpenVibe port. 
        *         (b)   This is good for general streaming data overall and rechecking alarm thresholds 
        *               later on (if the Level Index data are saved), but strictly, reanalysis of the data 
        *               should be done in the saved-data of split out from the OpenVibe CSVFileWriter module
        *       * Recommendations: This part can be improved in multiple ways  
        *         (a)   Read only the actual data point and have an option to save RMS,STFT data points,
        *               as well as the corresponding levels in different files
        *         (b)   Save in multiple indexed files every 30 minutes or so, instead of everything 
        *               in just one file, re-reading would be very heavy on the overhead 

        *   
        */
        public void DrawAndReport()
        {
            try
            {
                #region (1) Connect with the OpenVibe port
                TcpClient client = new TcpClient();
                client.Connect(APP_INP_PRM.hostname, APP_INP_PRM.port);

                // Update the initialization log with welcome message from APP_INP_PRM 
                UpdateInitialization("Connection successful!");

                // To read the streaming data 
                Byte[] bytes = new Byte[1024];
                int stream_read;
                int count = 0; // to count how many times the data have been read for representing time point (not the most accurate, but does the job well enough) 
                Stream stream = client.GetStream(); // the stream of incoming data 

                // To use later on 
                int[] chan_idx = { APP_INP_PRM.chan_idx2plt[0], APP_INP_PRM.chan_idx2plt[1] };
                int nchan = APP_INP_PRM.nchan;

                // To easily iterate over them because it's not recommended to create an array of these in the 
                // auto-generated (but still editable) MainForm.Designer.cs (meaning the MainForm.cs[Designer] 
                // would not show these objects in the array as we're editing the things in the MainForm.Designer.cs)
                Panel[] rms_alarm_panels = { rms_alarm1, rms_alarm2 };
                Panel[] lbp_alarm_panels = { lbp_alarm1, lbp_alarm2 };

                // Writing the data in a file 
                // Please refer to "CMT_SavOut" in the COMMENT section for further discussion and recommendations 
                string csvFilePath = APP_INP_PRM.output_file_name;
                File.WriteAllText(csvFilePath, "Data_1;RMS_1;RMSLevel_1;Data_2;RMS_2;RMSLevel_2\n");

                #region (2) WHILE loop to start reading the stream: While stream is still being read validly 
                // -------------------------------------------------------------------------------------------------------------                
                while ((stream_read = stream.Read(bytes, 0, bytes.Length)) != 0)
                {
                    // Please refer to "CMT_MatSndr" in the COMMENT section for discussion of validity 
                    #region (3) Reading data from stream as string and select valid data chunks 
                    string data_with_lines = System.Text.Encoding.ASCII.GetString(bytes, 0, stream_read);
                    string[] lines = data_with_lines.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                    lines = lines.Where(x => !x[0].Equals(',')).ToArray();
                    lines = lines.Where(x => x.Split(',').Length == APP_INP_PRM.chunk_len).ToArray();
                    #endregion (3) Reading data from stream as string and select valid data chunks 

                    if (lines.Length == 0) { continue; } // no meaningful data, so move on to reading the next chunk 
                    if (lines.Length > 0) // meaningful data 
                    {
                        int start_iline = (lines.Length == 1) ? 0 : 1; // if more than 1 chunk, read from lines[1] 
                        int end_iline = lines.Length;
                        for (int i_line = start_iline; i_line < end_iline; i_line++)
                        {
                            string data = lines[i_line];
                            string[] current_data_chunk = data.Split(','); // separate by comma 

                            #region (4) FOR each sample position in the chunk
                            // again, since each chunk is organized like 
                            // "ch0_data0, ch0_data1, ch0_data2, ch0_data3, ch1_data0,..., ch1_data3, ch2_data0,..., ch2_data3" 
                            // so we read "data0" first for all the channels we wish to plot, then read "data1", and so on
                            // until we read all the samples of the desired channels in the current chunk          
                            for (int ix = 0; ix < APP_INP_PRM.nsamp_per_block; ix++)
                            {
                                #region (5) Read and store current data point 
                                double t = ((double)count) / APP_INP_PRM.Fs; // convert `count` to a time point 
                                for (int ich = 0; ich < nchan; ich++) // for all the channel index to plot 
                                {
                                    // Parse in RMSCalcs to save to their `current_val` and `data_queue`
                                    bool parse_success = RMSCalcs[ich].ParseCurrentValue(current_data_chunk[ix + chan_idx[ich] * APP_INP_PRM.nsamp_per_block]);
                                    if (!parse_success) // just in case parse was unsuccessful 
                                    {
                                        Console.WriteLine("Warning: Parse unsuccessful with the input below");
                                        Console.WriteLine(data);
                                        break;
                                    }
                                }
                                #endregion (5) Read and store current data point 

                                #region (6) Visualizing for `channel_plots`
                                double[] viz = {    RMSCalcs[0].current_val,
                                                RMSCalcs[1].current_val,
                                                RMSCalcs[0].current_val - RMSCalcs[1].current_val };

                                UpdateTimeSeriesPlot(
                                    refreshable: APP_INP_PRM.refresh_display,
                                    cart_chart: channel_plots,
                                    series: ChannelSeries,
                                    t: t,
                                    values: viz,
                                    display_gains: APP_INP_PRM.display_channel_vertgains,
                                    display_offset: APP_INP_PRM.display_channel_vertoffset,
                                    max_sec_plt: APP_INP_PRM.max_sec_plt,
                                    max_pnt_plt: APP_INP_PRM.max_pnt_plt);
                                #endregion (6) Visualizing for `channel_plots`

                                #region (7) Visualizing for `rms_plots` and update the rms alarm panels 
                                Color[] rms_lvl_colors = new Color[nchan];
                                int[] rms_lvls = new int[nchan];
                                double[] current_rms_arr = new double[nchan], current_val_arr = new double[nchan];

                                for (int ich = 0; ich < nchan; ich++)
                                {
                                    // Calculate RMS 
                                    RMSCalcs[ich].CalculateRMS(count);
                                    current_rms_arr[ich] = RMSCalcs[ich].current_rms;
                                    current_val_arr[ich] = RMSCalcs[ich].current_val;

                                    // Update the colors of alarm panels and get the level indices to save later on 
                                    ReturnRMSLevel(current_rms_arr[ich], out rms_lvl_colors[ich], out rms_lvls[ich]);
                                    UpdatePanelColor(rms_alarm_panels[ich], rms_lvl_colors[ich]);

                                    // Tally up the alarm rates 
                                    RMSCalcs[ich].Tally_Levels(rms_lvls[ich]);
                                }

                                // Update the `rms_plots`
                                UpdateTimeSeriesPlot(
                                    refreshable: APP_INP_PRM.refresh_display,
                                    cart_chart: rms_plots,
                                    series: RMSSeries,
                                    t: t,
                                    values: current_rms_arr,
                                    display_gains: APP_INP_PRM.display_rms_vertgains,
                                    display_offset: APP_INP_PRM.display_rms_vertoffset,
                                    max_sec_plt: APP_INP_PRM.max_sec_plt,
                                    max_pnt_plt: APP_INP_PRM.max_pnt_plt);

                                #endregion (7) Visualizing for `rms_plots` and update the rms alarm panels 

                                #region (8) Visualizing for `spectral_plots` and `limbandpow_plots`
                                // Add the current channel data into the array in the STFT calculator
                                // If the array exceeds number the specifified nfft 
                                // then calculating the FFT of each channel data -> ready2plt = true 
                                for (int ich = 0; ich < nchan; ich++)
                                {
                                    STFTCalcs[ich].CalculateFFT(t, RMSCalcs[ich].current_val);
                                }

                                if (STFTCalcs[0].ready2plt)
                                {
                                    double[] viz_bp = new double[nchan]; // visulized band power 
                                    double[] pseudo_gains = new double[nchan]; // want all the gains = 1
                                    double pseudo_offset = 0;

                                    Color[] lbp_lvl_colors = new Color[nchan];
                                    int[] lbp_lvls = new int[nchan];

                                    for (int ich = 0; ich < nchan; ich++)
                                    {
                                        // Calculate the power spectrum density 
                                        STFTCalcs[ich].CalculatePSD();
                                        viz_bp[ich] = STFTCalcs[ich].band_power;
                                        pseudo_gains[ich] = 1.0;

                                        // Update the lbp alarm panel colors 
                                        ReturnLBPLevel(viz_bp[ich], out lbp_lvl_colors[ich], out lbp_lvls[ich]);
                                        UpdatePanelColor(lbp_alarm_panels[ich], lbp_lvl_colors[ich]);

                                        // Tally the alarm rates 
                                        STFTCalcs[ich].Tally_Levels(lbp_lvls[ich]);

                                    }
                                    // Update `spectral_plots` and `limbandpow_plots`
                                    UpdateSTFTPlot();
                                    UpdateTimeSeriesPlot(
                                        refreshable: APP_INP_PRM.refresh_display,
                                        cart_chart: limbandpow_plots,
                                        series: LBPSeries,
                                        t: t,
                                        values: viz_bp,
                                        display_gains: pseudo_gains,
                                        display_offset: pseudo_offset,
                                        max_sec_plt: APP_INP_PRM.max_sec_plt,
                                        max_pnt_plt: APP_INP_PRM.max_pnt_plt);

                                }
                                #endregion (8) Visualizing for `spectral_plots` and `limbandpow_plots`

                                #region (9) Visualizing for the rms alarm rate plots
                                // If nonzero `count` hits the reset point then we can start 
                                // plotting the rms alarm rate plot
                                if (count % APP_INP_PRM.rms_lvl_reset_point == 0 && count > 0)
                                {
                                    int n_lvls = RMSCalcs[0].n_lvls;
                                    double[] rms_lvl_arrs = new double[n_lvls];
                                    double[] pseudo_gains = new double[n_lvls];
                                    double pseudo_offset = 0;

                                    if (APP_INP_PRM.alarm_rate_plt_stack)
                                    {
                                        // If we stack the rate on top of each other
                                        // Normal at bottom, Warning middle, Danger top 
                                        // Then the higher levels would accumulate from lower levels
                                        // to make them stack on top of each other 
                                        // when plotting with Fill option of the Series on 
                                        // with high Opacity 
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            RMSCalcs[ich].Cumulative_From_Lower_Level();
                                        }
                                    }
                                    // The alarm rate to plot will be aggregated from both channels 
                                    // instead of just one for simplicity and easier labeling/legending 
                                    for (int ilvl = 0; ilvl < n_lvls; ilvl++)
                                    {
                                        pseudo_gains[ilvl] = 1.0;
                                        rms_lvl_arrs[ilvl] = 0;
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            rms_lvl_arrs[ilvl] += RMSCalcs[ich].rms_levels[ilvl];
                                        }
                                    }

                                    // Then we update `rms_alarm_plots`
                                    // The alarm rate plots are set to be continuous instead of refreshable 
                                    // because we'd want to look at the history of the alarm rates throughtout 
                                    // a longer amount of time. If it were refreshable (say every 20minutes), 
                                    // then we'd lose the last 20min of observation immediately after 21minutes. 
                                    // The refreshable option is usually good for viewing short amount of time,
                                    // but with higher sampling/updating rate. 
                                    UpdateTimeSeriesPlot(
                                        refreshable: false,
                                        cart_chart: rms_alarm_plots,
                                        series: RMSAlarmSeries,
                                        t: t,
                                        values: rms_lvl_arrs,
                                        display_gains: pseudo_gains,
                                        display_offset: pseudo_offset,
                                        max_sec_plt: APP_INP_PRM.rms_lvl_max_sec,
                                        max_pnt_plt: APP_INP_PRM.rms_lvl_max_point);

                                    // Need to reset the tally 
                                    for (int ich = 0; ich < nchan; ich++)
                                    {
                                        RMSCalcs[ich].Reset_Level_Tally();
                                    }


                                }
                                #endregion (9) Visualizing for the rms alarm rate plots

                                #region (10) Visualizing for the lbp alarrm rate plots 
                                // If nonzero `count` hits the reset point then we can start 
                                // plotting the lbp alarm rate plot
                                if (count % APP_INP_PRM.lbp_lvl_reset_point == 0 && count > 0)
                                {
                                    int n_lvls = STFTCalcs[0].n_lvls;
                                    double[] lbp_lvl_arrs = new double[n_lvls];
                                    double[] pseudo_gains = new double[n_lvls];
                                    double pseudo_offset = 0;

                                    if (APP_INP_PRM.alarm_rate_plt_stack)
                                    {
                                        // If we stack the rate on top of each other
                                        // Normal at bottom, Warning middle, Danger top 
                                        // Then the higher levels would accumulate from lower levels
                                        // to make them stack on top of each other 
                                        // when plotting with Fill option of the Series on 
                                        // with high Opacity 
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            STFTCalcs[ich].Cumulative_From_Lower_Level();
                                        }
                                    }
                                    // The alarm rate to plot will be aggregated from both channels 
                                    // instead of just one for simplicity and easier labeling/legending 
                                    for (int ilvl = 0; ilvl < n_lvls; ilvl++)
                                    {
                                        pseudo_gains[ilvl] = 1.0;
                                        lbp_lvl_arrs[ilvl] = 0;
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            lbp_lvl_arrs[ilvl] += STFTCalcs[ich].lbp_levels[ilvl];
                                        }
                                    }

                                    // Then we update `lbp_alarm_plots`
                                    // The alarm rate plots are set to be continuous instead of refreshable 
                                    // because we'd want to look at the history of the alarm rates throughtout 
                                    // a longer amount of time. If it were refreshable (say every 20minutes), 
                                    // then we'd lose the last 20min of observation immediately after 21minutes. 
                                    // The refreshable option is usually good for viewing short amount of time,
                                    // but with higher sampling/updating rate. 
                                    UpdateTimeSeriesPlot(
                                        refreshable: false,
                                        cart_chart: lbp_alarm_plots,
                                        series: LBPAlarmSeries,
                                        t: t,
                                        values: lbp_lvl_arrs,
                                        display_gains: pseudo_gains,
                                        display_offset: pseudo_offset,
                                        max_sec_plt: APP_INP_PRM.lbp_lvl_max_sec,
                                        max_pnt_plt: APP_INP_PRM.lbp_lvl_max_point);

                                    // Need to reset the tally 
                                    for (int ich = 0; ich < nchan; ich++)
                                    {
                                        STFTCalcs[ich].Reset_Level_Tally();
                                    }


                                }
                                #endregion (10) Visualizing for the lbp alarrm rate plots 

                                #region (11) Update the clock time 
                                TimeSpan tsp = TimeSpan.FromSeconds(t);
                                UpdateLabel(clock, tsp.ToString(@"hh\:mm\:ss\:fff"));
                                #endregion (11) Update the clock time 

                                #region (12) Saving the current data 
                                string nextLine = string.Format("{0};{1};{2};{3};{4};{5}\n",
                                    current_val_arr[0], current_rms_arr[0], rms_lvls[0],
                                    current_val_arr[1], current_rms_arr[1], rms_lvls[1]);
                                File.AppendAllText(csvFilePath, nextLine);
                                #endregion (12) Saving the current data 

                                count++;
                            }
                            #endregion (4) FOR each sample position in the chunk
                        }
                    }
                }
                // -------------------------------------------------------------------------------------------------------------  
                // End of While loop 
                #endregion (2) WHILE loop to start reading the stream: While stream is still being read validly 
                // Close the `client`
                client.Close();

                #endregion (1) Connect with the OpenVibe port            
            }

            catch (Exception e)
            {   
                // Usually if there are connections issues
                // For example, the program is run but no connection is currently established,
                // like, the OpenVibe side is not initiated 
                // If so, retry again 
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                Console.WriteLine("!!!!\t" + e.StackTrace);
                DrawAndReport();
            }
        }

        #endregion DrawAndReport function

        #region Events of Buttons 

        /* exit_button_Click: Click event to of the `exit_button` to close the program 
         */
        private void exit_button_Click(object sender, EventArgs e)
        {
            Application.Exit();
            Environment.Exit(1);
        }

        /* The functions below are very similar to each other, their purpose is to update the DISPLAY (not actual values)  
         * vertical gain or offset of either channel (X=chan) and RMS (X=RMS) plot series, and show the changed values nearby 
         *      `XY_Z_Click` would update either 
         *          (a) all the elements of display vertical gain array (X=gain) or 
         *          (b) the display vertical offset value (X=offset) in
         *      `APP_INP_PRM` on the go by adding (X=up) or subtracting (X=down) with the
         *      appropriate change step = either `APP_INP_PRM.d_gain` or `APP_INP_PRM.d_offset`.
         *      Then also update the label `X_Y_val`, with the newly updated arrays of gain or value of offset. 
         */

        #region  Channel gain and separation control for display 
        private void changain_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Verical_Gain(1);
            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }
        private void changain_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Verical_Gain(-1);
            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }
        private void chanoffset_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Vertical_Offset(1);
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
        }
        private void chanoffset_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Vertical_Offset(-1);
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
        }
        #endregion  Channel gain and separation control for display 

        #region  RMS gain and separation control for display 
        private void rmsgain_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Vertical_Gain(1);
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }
        private void rmsgain_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Vertical_Gain(-1);
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }
        private void rmsoffset_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Vertical_Offset(1);
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));
        }
        private void rmsoofset_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Vertical_Offset(-1);
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));
        }
        #endregion  RMS gain and separation control for display 

        #endregion Events of Buttons 

    }
}
