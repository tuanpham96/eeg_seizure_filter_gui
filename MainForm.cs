using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net.Sockets;

using LiveCharts;
using LiveCharts.WinForms;
using LiveCharts.Wpf;
using LiveCharts.Configurations;
using LiveCharts.Defaults;
using LiveCharts.Geared;
using System.Linq;
using System.Collections.Generic;

/** SEIZURE FILTER EEG PROGRAM
 * Started by Dominic DiCarlo September 2018

    + REQUIREMENTS: 

            This program requires communication with OpenViBE acquisition software
        as well as designer software.That software can be obtained from
        Brain Products, and is found on the flash drive Towle lab
        received from them.

    + SUMMARY OF PURPOSE:
    
            This program reads in data from a TCP server generated by OpenViBE Designer
        It takes in the data given at 512 Hz signal delivered in 4 sample chunks
        (or a 128 Hz signal delivering 4 samples at a time) and calculates
        the RMS to(theoretically) predict when a seizure might be coming on.

            If the RMS approaches certain upper or lower bounds, the graphical interface
        of the program will change the color of a bar to signify this, from green (safe)
        to yellow (caution), to red (danger). Right now, the upper and lower bounds of
        these ranges has been arbitrarily decided. To use this program for the
        visual prosthesis, these values will either have to be pre-determined
        or determined after experimentation has begun.We must decide whether to
        err on the side of safety or risk.

    + EXECUTION: 
        1)  Connect the V-Amplifier to the computer and install any drivers
            you may be prompted to. The Brain Products usb will also install some drivers
            to your PC; these are needed for the V-Amp (supposedly)

        2)  Open OpenViBE Acquisition Server. Select V-Amp/Fast Amp from the Driver drop
            down menu. Adjust drift tolerance to 2.00 ms or lower from the Preferences button.
            Set "Sample count per sent block" to 4.

        3)  Open OpenViBE Designer. If this is your first time, select
            an "Acquisition Client" box from the folder "Acquisition and network IO".
            connect this to a "Temporal filter" box from '"Signal Processing"->"Temporal Filtering"'.
            Connect the "Temporal filter" box to a "Signal display" box and a "Matrix sender" box.

            NOTE #1 : Assure the "Matrix sender" box has TCP port "1234". You can check this by
            double clicking it, and seeing the TCP port. 

            NOTE #2: Assure the "Acquisition client" box has the same acquisition server
            port as the Connection port number on OpenViBE Acquisition Server. You can check the box
            by double clicking it, and the actual Acquisition Server right on the front of the program

            All the program really needs from designer is the "Matrix Sender", as this is what it reads.
            Feel free to adjust the Temporal Filter to your exact frequency needs,
            as well as adjust the signal display parameters for your needs. 

            You can save your settings in OpenViBE Designer as a config file. Simply
            click Save As at the top or Save. 

        4)  Hit Start at the top of Visual Studio, or run this program in the packaged way
            you have decided. Then, hit the play arrow on top of OpenViBE designer. 
            Voila! The program should be running. If not, run through these steps again
            and ensure you have done everything right.


    + FUTURE CONSIDERTIONS:

        1)  It would be nice to be able to change the upper and lower bounds of the RMS
            safety window from the GUI. This change could be easily made

        2)  Adding more channels and the ability to manage multiple samples from the stream at once.
            - There is room in the logic to do this, and it would just look like more of the same code. 
            We would need to decide how many channels we want to look at in the first place.

        3)  Adding in EEG visualization
            - OpenViBE supplies this in the mean time, but creating our own EEG viewer
            would be optimal as we can modify it to suit our needs.

        4)  Some visualization of the RMS over time
            - This would be very useful, as right now we only get monitoring of the present
            state of the RMS, and we might want to look at the trends it is taking.

        5)  Writing the CSV of values from the experiment in a path that will work for all systems
            - Right now, the CSV path has to be edited in the code
            so that it works on other systems.What would be more ideal
            would be the user selecting a path before the program begins.
            This would be easy to program.

    The logic of everything is simplified right now to only work with one
    channel and one sample at a time.This is then a skeleton for more work
    depending on how much data you want to use.
*/

namespace seizure_filter
{
    // MainForm first prompts for input then streamed EEG related data 
    public partial class MainForm : Form
    {
        #region MainForm attributes/properties 
        /* Application input parameters - from Prompt ouput or an existing configuration file 
         * - This is necessary to set up neccessary parameters for 
         * (a) Reading streaming data from the correct port, 
         * (b) Data calculations, and
         * (c) Visualization options 
         * - There are three options from Prompt:  
         * (1) Create a completely new configuration file, with parameters loaded from 
         *      a default configuration file (`_config_file.txt`: please don't modify this regularly),
         *      then save the configuration file 
         * (2) Load an existing configuration, and modify the configutation in Prompt.
         *      Then opt to either save it as a new file or overwrite it. 
         *      The warning of overwriting is not yet implemented so be careful
         * (3) Load an existing configutation, then start MainForm to plot, 
         *      meaning Prompt would not appear to modify parameters.
         *      The warning for loading an non-existing file is not yet implemented 
         * The general idea is: when one first starts, option (1) is prefered to create an initial configuration 
         *                      then later on, option (2) is preferred to start modifying the parameters (for example: alarm thresholds) 
         *                      once configuration is settled, option (3) is prefered, 
         *                      and occasional going back to (2) for small modifications
         */ 
        private AppInputParameters APP_INP_PRM;
        /* Thread to run DrawAndReport 
         */
        private Thread logic_thread;

        /* Array of calculators
         * + STFTCalcs: Array of Short-time Fourier transform calcultors, 
         *              contains information and calculation on spectral analysis, 
         *              and spectral alarm rates
         * + RMSCalcs:  Array of Root-mean-square calculators, and the queue of current data      
         *               contains information and calculation on current data and RMS, 
         *               and RMS alarm rates
         */   
        public STFTCalculator[] STFTCalcs;
        public RMSCalculator[] RMSCalcs;
        /* Array of series to pass on values to be recognized by the plotting module/library 
         * Briefly, `ChannelSeries`, `RMSSeries`, `LBPSeries` are Time Series (meaning x_axis is time) 
         * While `STFTSeries` X axis is Frequency 
         * The `RMSAlarmSeries` and `LBPAlarmSeries` are also Time Series, but at a slower update rate. 
         * + ChannelSeries:     Channel values, and their difference; 
         *                      - For now implemented only 2 channels + their difference 
         *                      - However, it is possible to generalize, as long as do not include pair difference
         *                      - Generalization with pairwise difference plotting might mean creating a separate plot pannel 
         * + RMSSeries:         Root-mean-square values of the channels 
         *                      - Sliding RMS window, with specified length in the prompt 
         * + STFTSeries:        Short-time Fourier transform values of the (normalized) channels 
         *                      - Channel data are normalized by mean and variance before doing STFT 
         *                      - There's also an option to use single tapers to the normalized data before STFT 
         * + LBPSeries:         Limited band power of the channels
         *                      - Sum of squares of the magnitude of STFT, with the option to scale to Fs and applied taper (refer to the implementation )
         *                      - The frequency band is specified by prompt 
         * + RMSAlarmSeries:    RMS alarm rate over 3 alarm levels (Normal=0, Warning=1, Danger=2) 
         *                      - The rate is updated for every particular duration of time (for example, every 2s) then reset 
         *                      - The duration is specified in prompt 
         * + LBPAlarmSeries:    LBP alarm rate over 3 alarm levels (Normal=0, Warning=1, Danger=2) 
         *                      - Similarly set up like RMS alarm rate 
         *                      - The duration is specified separately from RMSAlarmSeries 
         */
        public GearedValues<ObservablePoint>[] ChannelSeries;
        public GearedValues<ObservablePoint>[] RMSSeries;
        public GearedValues<ObservablePoint>[] STFTSeries;
        public GearedValues<ObservablePoint>[] LBPSeries;
        public GearedValues<ObservablePoint>[] RMSAlarmSeries;
        public GearedValues<ObservablePoint>[] LBPAlarmSeries;
        #endregion

        #region Constructor and Initialization 

        /* MainForm initialization 
         * + SUMMARY: 
         *      (1) Initialize the components of the form (the set up of the form),
         *          - Refer to autogenerated `MainForm.Designer.cs` for more information 
         *              about the different components in th UI 
         *      (2) Prompting for parameter input,
         *          - Refer to `Prompt.cs` and `AppInputParameters.cs` for more information 
         *      (3) Initialize Calculators, Plotting Series and Plotting Setup, 
         *          - Refer to `---Calculator.cs` files for more information about Calculators set ups 
         *          - Refer to online documentation of the plotting module `LIVECHARTS` 
         *              for set up of Plotting Series and Plotting Setup 
         *      (4) Load the form to start streaming data once everything is set
         *          - The main layout is in `DrawAndReport` method
         * + REQUIREMENTS: 
         *      - OpenVibe_Designer:    + For designing the communication set up with 
         *                                  `OpenVibe_Acquisition` (or with sinusoidal simulator) to this program. 
         *                              + In short, this is the middle man/woman/human/stuff.  
         *      - OpenVibe_Acquisition: + For connecting with EEG set up with `OpenVibe_Designer` setup.
         *                              + This would not be necessary when running sinusoidal simulator in `OpenVibe_Designer`.
         *      - LiveCharts:           + Plotting module/library in this, a lot of the code is 
         *                                  about setting up configuration to use this module. 
         *                                  Hence, these details can be ignored during migration to another language 
         *                              + LiveCharts.Geared is also used here because it is optimized for 
         *                                  faster plotting of streaming data. It is however commerical. 
         *                                  However, have not paid for it yet. Not sure why. My guess is 
         *                                  that just the `LiveCharts.Geared.Wpf` is commerical, and I'm using 
         *                                  `LiveCharts.Geard` mainly for `WindowsForm`, which might not commerical.
         *                                  I was able to install it from NuGet, so have been using it still. 
         *      - Accord.Math:          + For Fourier Transform 
         * + GENERAL INPUT: 
         *      - Streaming data from EEG recording channels, supposedly 
         *      - Requires correct set up from the OpenVibe Designer and Acquisition 
         *      - Then need an `APP_INP_PRM` object from `Prompt` and/or an existing configuration file to create 
         *          (APP_INP_PRM: details of configuration for reading data, calculations and plotting)
         * + GENERAL OUTPUT: 
         *      (1) Occipital EEG data, see `ChannelSeries` and `channel_plots`
         *      (2) Their difference, see `ChannelSeries` and `channel_plots`
         *      (3) Root mean square (RMS), see `RMSSeries` and `rms_plots`
         *      (4) Short-time Fourier transform (STFT), see `STFTSeries` and `spectral_plots`
         *      (5) Limited band power (LBP), see `LBPSeries` and `limbandpow_plots`   
         *      (6) Alarm rates for 3 alarm levels of RMS, see `RMSAlarmSeries` and `rms_alarm_plots`
         *      (7) Alarm rates for 3 alarm levels of LBP, see `LBPAlarmSeries` and `lbp_alarm_plots`
         */
        public MainForm()
        {
            InitializeComponent();
            using (Prompt prompt = new Prompt(title:"ENTER THE INPUT PARAMETERS", caption:"Input parameters"))
            {
                APP_INP_PRM = prompt.Result;
            }
            APP_INP_PRM.CompleteInitialize();

            InitializeCalculators();
            InitializePlotSeries();
            InitializePlotSetUp(); 
            Load += MainForm_Load;
        }

        /* MainForm_Load: creating a thread to start `DrawAndReport`
         * I believe there are many improvements that can be made to this 
         * for allocating resources to calculating and plotting 
         * I'm not really familiar with threading, unfortunately. 
         */ 
        private void MainForm_Load(object sender, EventArgs e)
        {
            logic_thread = new Thread(DrawAndReport);
            logic_thread.Start();
        }

        /* InitializeCalculators: initialize calculators for storing streaming channel data, RMS and spectral calculations 
         * Refer to `RMSCalculator.cs` and `STFTCalculator` for more information 
         */ 
        private void InitializeCalculators()
        {
            int nchan = APP_INP_PRM.nchan;
            STFTCalcs = new STFTCalculator[nchan];
            RMSCalcs = new RMSCalculator[nchan];
            for (int i = 0; i < nchan; i++)
            {
                RMSCalcs[i] = new RMSCalculator(
                    nmax_queue_total:   APP_INP_PRM.nmax_queue_total, 
                    n_lvls:             APP_INP_PRM.n_lvls);

                STFTCalcs[i] = new STFTCalculator(
                    Fs:                 APP_INP_PRM.Fs,
                    n_epoch:            APP_INP_PRM.n_epoch,
                    n_skip:             APP_INP_PRM.n_skip,
                    n_lvls:             APP_INP_PRM.n_lvls,
                    BPFR:               new double[] { APP_INP_PRM.f_bandpower_lower, APP_INP_PRM.f_bandpower_upper },
                    win_type:           APP_INP_PRM.window_type,
                    scaling_psd:        APP_INP_PRM.scaling_psd,
                    file_prefix:        APP_INP_PRM.output_file_name,
                    saving_option:      APP_INP_PRM.stft_saving_option);

            }
        }

        /* InitializePlotSeries: initialize the series (`__Series objects) to "communicate" with the CartesianCharts objects (`__plots` objects in the `MainForm.Designer.cs`) 
         * Much of this can be ignored when migrating to another language. 
         * A lot of this is sort of hard-coded sadly so, again, would not make much sense to migrate.
         * However, this can be improved if the channel difference data are plotted on another CartesianCharts object instead of in the same plot as in `channel_plots`
         * If that is done, much of the "design" choices can then be set in the configuration set up (saved in `APP_INP_PRM` and prompted by `Prompt`) 
         */
        private void InitializePlotSeries()
        {
            int nchan = APP_INP_PRM.nchan;

            // Mapper of ObservablePoint for plotting later on 
            var mapper = Mappers.Xy<ObservablePoint>().X(value => value.X).Y(value => value.Y);
            Charting.For<ObservablePoint>(mapper);

            // Here is where the limit happens, meaning could only plot 2 channels + 1 line series of their difference 
            // Plotting the difference in another CartesianChart in a more systematic way would enable this to 
            //      generalize to many more channels to be plot. However, the problem with labelling the pairwise difference 
            //      with more than a few channels would be hard, as that would be a combinatoral of 2 over N channels. 
            // The reason for 2 channels + 1 difference was to observe 2 occipital EEG channels supposedly during stimulation.
            //      Since stimulation would be on 1 side, the difference data would reflect the asymmetric seizure appearance were there to be any. 
            string[] legends = {"Ch " + APP_INP_PRM.chan_idx2plt[0],
                                "Ch " + APP_INP_PRM.chan_idx2plt[1],
                                "Ch " + APP_INP_PRM.chan_idx2plt[0] + " - Ch " + APP_INP_PRM.chan_idx2plt[1]};
            System.Windows.Media.DoubleCollection[] dashed_style =
            {
                new System.Windows.Media.DoubleCollection(new double[] { 1,0 }),  // solid for first incoming channel 
                new System.Windows.Media.DoubleCollection(new double[] { 5,2 }),  // dashed for second 
                new System.Windows.Media.DoubleCollection(new double[] { 1,0 })   // solid for their difference 
            };
            System.Windows.Media.SolidColorBrush[] ch_brushes =
            {
                 System.Windows.Media.Brushes.Black,
                 System.Windows.Media.Brushes.Gray,
                 System.Windows.Media.Brushes.Red
            };

            // `ChannelSeries` setup then add to `chanel_plots` 
            ChannelSeries = new GearedValues<ObservablePoint>[nchan + 1];
            for (int idx_obs = 0; idx_obs < nchan + 1; idx_obs++)
            {
                ChannelSeries[idx_obs] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality // needed for Geared to perform well 
                };
                channel_plots.Series.Add(new GLineSeries
                {
                    Values = ChannelSeries[idx_obs],
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    StrokeThickness = 2,
                    Fill = System.Windows.Media.Brushes.Transparent,
                    Stroke = ch_brushes[idx_obs],
                    Title = legends[idx_obs] + " \t"
                });
            }

            // `RMSSeries` setup then add to `rms_plots`
            // `STFTSeries` setup then add to `spectral_plots`
            // `LBPSeries` setup tthen add to `limbandpow_plots`
            RMSSeries = new GearedValues<ObservablePoint>[nchan];
            STFTSeries = new GearedValues<ObservablePoint>[nchan];
            LBPSeries = new GearedValues<ObservablePoint>[nchan];
            for (int ichan = 0; ichan < nchan; ichan++)
            {
                RMSSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                rms_plots.Series.Add(new GLineSeries
                {
                    Values = RMSSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = new System.Windows.Media.SolidColorBrush { Color = System.Windows.Media.Color.FromArgb(50, 128, 89, 123) },
                    Title = legends[ichan] + " RMS",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });

                STFTSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                spectral_plots.Series.Add(new GLineSeries
                {
                    Values = STFTSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = System.Windows.Media.Brushes.Transparent,
                    Title = legends[ichan] + " STFT",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });

                LBPSeries[ichan] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                limbandpow_plots.Series.Add(new GLineSeries
                {
                    Values = LBPSeries[ichan],
                    StrokeThickness = 2,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = new System.Windows.Media.SolidColorBrush { Color = System.Windows.Media.Color.FromArgb(50, 100, 120, 200) },
                    Title = legends[ichan] + " BP",
                    Stroke = ch_brushes[ichan],
                    StrokeDashArray = dashed_style[ichan]
                });
            }

            // Alarm levels are set to 3 here, 
            // + Normal = 0 
            // + Warning = 1
            // + Danger = 2
            // There's a way to generalize this, but I though that 3 levels are 
            //      probably quite sufficient to look at already since there would be 
            //      3 colors to look at. More than that, I would argue could be 
            //      overwhelming and distracting.
            // Regardless, generalization would mean having these as options back in `AppInputParameters.cs` and 
            //      prompt for such configurations in `Prompt`. 
            int n_lvls = APP_INP_PRM.n_lvls;
            System.Windows.Media.SolidColorBrush[] brushes =
            {
                AppInputParameters.ColorToBrush(APP_INP_PRM.normal_color),
                AppInputParameters.ColorToBrush(APP_INP_PRM.warning_color),
                AppInputParameters.ColorToBrush(APP_INP_PRM.danger_color)
            };
            string[] alarm_lvl_str = { "Normal", "Warning", "Danger" };

            // There are 2 ways to plot: either 
            // (1) area-stack them on top of each other, with Normal bottom, Warning middle then Danger on top; or
            // (2) just plot them as lines for easily inspection of alarm rate trend 
            //      since stacking might sometimes be hard to tell the trend 
            // There's an option in LiveCharts to plot StackedArea explicitly but I chose to manually implement it 
            //      by doing the LineSeries instead by basically adding them up for uniformity of code 
            //      refer to `RMSCalculator.Cumulative_From_Lower_Level` 
            //      or `STFTCalculator.Cumulative_From_Lower_Level` for details.
            // Hence, to maintain that uniformity in the area-stack implementation, 
            //      the order of the series matters due to overlaying effects of series added later. 
            int i_start, i_bound, i_incr, i_sign_cond;
            double stroke_thickness, alarm_rate_opacity;
            System.Windows.Media.Geometry point_geom = DefaultGeometries.None;
            if (APP_INP_PRM.alarm_rate_plt_stack) // stack them up 
            {
                // equilvalent to `for (int i = n_lvls-1; i >= 0; i--)`   
                // meaning the Danger one gets added first, hence would be the one way in the back 
                // hence calling `Cumulative_From_Lower_Level` would be to make it higher but still maintain the right proportion
                // when taken into account all the levels. 
                i_start = n_lvls - 1;
                i_bound = -1;
                i_sign_cond = 1;
                i_incr = -1;

                stroke_thickness = 1.50;
                alarm_rate_opacity = 0.9;
            }
            else // regular line plot - which is the default 
            {
                // equilvalent to `for (int i = 0; i < n_lvls; i++)`
                i_start = 0;
                i_bound = n_lvls;
                i_sign_cond = -1;
                i_incr = +1;

                stroke_thickness = 4.5;
                alarm_rate_opacity = 0.0;
            }

            // `RMSAlarmSeries` setup then add to `rms_alarm_plots`
            // `LBPAlarmSeries` setup then add to `lbp_alarm_plots`
            RMSAlarmSeries = new GearedValues<ObservablePoint>[n_lvls];
            LBPAlarmSeries = new GearedValues<ObservablePoint>[n_lvls];
            for (int i = i_start; i.CompareTo(i_bound) == i_sign_cond; i += i_incr)
            {
                RMSAlarmSeries[i] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                rms_alarm_plots.Series.Add(new GLineSeries
                {
                    Values = RMSAlarmSeries[i],
                    StrokeThickness = stroke_thickness,
                    PointGeometry = point_geom,
                    PointForeground = brushes[i],
                    LineSmoothness = 1,
                    Fill = new System.Windows.Media.SolidColorBrush
                    {
                        Opacity = alarm_rate_opacity,
                        Color = brushes[i].Color
                    },
                    Stroke = brushes[i],
                    Title = alarm_lvl_str[i]
                });

                LBPAlarmSeries[i] = new GearedValues<ObservablePoint>
                {
                    Quality = APP_INP_PRM.display_quality
                };
                lbp_alarm_plots.Series.Add(new GLineSeries
                {
                    Values = LBPAlarmSeries[i],
                    StrokeThickness = stroke_thickness,
                    PointGeometry = point_geom,
                    PointForeground = brushes[i],
                    LineSmoothness = 1,
                    Fill = new System.Windows.Media.SolidColorBrush
                    {
                        Opacity = alarm_rate_opacity,
                        Color = brushes[i].Color
                    },
                    Stroke = brushes[i],
                    Title = "\n" + alarm_lvl_str[i] + "\n" // to space the legend out a bit 
                });
            }
        }

        /* InitializePlotSetUp: initialize plot axes/legend setup options and maximize plotting performance  
         * Refer `PlotSetUpAndMaximizePerformance` for further descriptions
         * Much of this is manual, hence can be ignored while migrating to another language 
         */ 
        private void InitializePlotSetUp() {  
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref channel_plots,
                axes_label:     new Axes_Label(xlabel: "Time (s)", ylabel:"Voltage (uV)"),
                axes_limit:     null,
                x_axis_merged:  false,
                y_axis_merged:  true,
                lgnd_loc:       LegendLocation.Top);
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref rms_plots, 
                axes_label:     new Axes_Label(xlabel:"Time (s)", ylabel:"RMS (uV)"), 
                axes_limit:     null, 
                x_axis_merged:  false, 
                y_axis_merged:  true,
                lgnd_loc:       LegendLocation.None);
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref spectral_plots,
                axes_label:     new Axes_Label(xlabel:"Frequency (Hz)", ylabel:"FFT (AU)"),
                axes_limit:     new Axes_Limit(xlim:new double[] { -0.1, 40 }, ylim:new double[] { 0, double.PositiveInfinity }));
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref limbandpow_plots, 
                axes_label:     new Axes_Label(xlabel:"Time (s)", ylabel:string.Format("Band power {0} - {1} Hz (AU)", APP_INP_PRM.f_bandpower_lower, APP_INP_PRM.f_bandpower_upper)), 
                axes_limit:     null, 
                x_axis_merged:  false,
                y_axis_merged:  true);
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref rms_alarm_plots, 
                axes_label:     new Axes_Label(xlabel:"Time (s)", ylabel:"# of RMS alarms"));
            PlotSetUpAndMaximizePerformance(
                cart_chart:     ref lbp_alarm_plots, 
                axes_label:     new Axes_Label(xlabel:"Time (s)", ylabel:"# of Spectral alarms"),
                axes_limit:     null,
                x_axis_merged:  false, 
                y_axis_merged:  false,
                lgnd_loc:       LegendLocation.Left);

        }

        /* Axes_Label: struct for x and y axis labels 
         */ 
        private struct Axes_Label
        {
            public string xlabel, ylabel;
            public Axes_Label(string xlabel, string ylabel)
            {
                this.xlabel= xlabel;
                this.ylabel= ylabel;
            }
        }

        /* Axes_Limit: class for setting limits of axes 
         * Generally if any element is a DOUBLE.POSITIVE_INFINITY or NEGATIVE_INFINITY then the limit is not set
         * For example, + if xlim = {0, +INF} then always set the plot x-axis to have lowest bound as 0, 
         *              but upper bound will be set by LiveCharts automatically 
         *              + if xlim = {-INF, +INF} then LiveCharts will set the limit automatically,
         *              according to the plotted streamed data values 
         *              + and so on for other scenarios for both xlim and ylim. 
         */
        private class Axes_Limit
        {
            public double xlow, xhigh, ylow, yhigh;
            private readonly double[] xlim, ylim;
            public void Check_Limit_Validity(double[] inp)
            {
                if (inp.Length != 2)
                {
                    throw new System.ArgumentOutOfRangeException("The input limit range needs to be a double array of only 2 elements"); 
                }
                if (inp[0] >= inp[1] && !double.IsInfinity(inp[0]) && !double.IsInfinity(inp[1]))
                {
                    throw new System.ArgumentException(string.Format("The lower bound (1st element = {0}) needs to be smaller" +
                        " than the upper bound (2nd element = {1})", inp[0], inp[1])); 
                }
            }
            public Axes_Limit(double[] xlim, double[] ylim)
            {
                this.xlim = xlim;
                this.ylim = ylim;
                xlow = xlim[0];
                xhigh = xlim[1];
                ylow = ylim[0];
                yhigh = ylim[1];
                Check_Limit_Validity(this.xlim);
                Check_Limit_Validity(this.ylim);
            }
        }

        /* PlotSetUpAndMaximizePerformance: setting the plot (CartesianChart objects) axes and legend options + maximize plotting performance 
         * + REFERENCE:
         *      (1) Axes set up:      https://lvcharts.net/App/examples/v1/wf/Axes
         *      (2) Performance tips: https://lvcharts.net/App/examples/v1/wf/Performance%20Tips
         * + INPUT: 
         *      - cart_chart:       the reference of the CartesianChart object to set these options 
         *      - axes_label:       Axes_Label object to set labels for x-axis and y-axis 
         *      - axes_limit:       Axes_Limit object to set limits for x-axis and y-axis 
         *                          default is "null", meaning not setting the limits manually 
         *      - x_axis_merged:    merge the x-tick values onto the axis to save space, refer to ref. (1) 
         *                          default is "false", meaning not merged
         *                          however, should set to "true" for the 3 middle time series plots
         *                          because the representation of the values could change the widths of 
         *                          the main plot, which could be misleading when trying to compare between 
         *                          the 3 time series plots in the middle. 
         *      - y_axis_merged:    merge the y-tick values onto the axis to save space, refer to ref. (1) 
         *                          default is "false", meaning not merged
         *                          however, should set to "true" for the 3 middle time series plots
         *                          because the representation of the values could change the widths of 
         *                          the main plot, which could be misleading when trying to compare between 
         *                          the 3 time series plots in the middle. 
         *      - lgnd_loc:         location of the legend in the plot, refer to ref. (1) 
         *                          only 5 options {"Bottom", "Top", "Right", "Left", "None"}
         *                          default is "LegendLocation.None"
         * + OUTPUT: 
         *      - NONE
         *      - Set up the options for axes and legend locations 
         *      - Then maximize plot performacne for streaming data, refer to ref. (2) 
         */
        private void PlotSetUpAndMaximizePerformance(   ref LiveCharts.WinForms.CartesianChart cart_chart, 
                                                        Axes_Label axes_label, 
                                                        Axes_Limit axes_limit = null,
                                                        bool x_axis_merged = false, 
                                                        bool y_axis_merged = false,
                                                        LegendLocation lgnd_loc = LegendLocation.None)
        {
            // Axes options 
            string font_fam = "Microsoft Sans Serif";
            var axes_color = System.Windows.Media.Brushes.Gray;
            cart_chart.Font = new Font(font_fam, 12F);
            cart_chart.ForeColor = AppInputParameters.BrushToColor(axes_color); 

            cart_chart.AxisX.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 1, Stroke = axes_color, IsEnabled = false},
                FontSize = 20F,
                FontFamily = new System.Windows.Media.FontFamily(font_fam),
                Foreground = axes_color,
                Title = axes_label.xlabel,          
                IsMerged = x_axis_merged
            });

            cart_chart.AxisY.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 1, Stroke = axes_color, IsEnabled = false },
                FontSize = 20F,
                FontFamily = new System.Windows.Media.FontFamily(font_fam),
                Foreground = axes_color,
                Title = axes_label.ylabel,
                IsMerged = y_axis_merged,  
                
            });
            // Axes limit 
            if (axes_limit != null)
            {
                if (!double.IsInfinity(axes_limit.xlow)) { cart_chart.AxisX[0].MinValue = axes_limit.xlow; }
                if (!double.IsInfinity(axes_limit.xhigh)) { cart_chart.AxisX[0].MaxValue = axes_limit.xhigh; }

                if (!double.IsInfinity(axes_limit.ylow)) { cart_chart.AxisY[0].MinValue = axes_limit.ylow; }
                if (!double.IsInfinity(axes_limit.yhigh)) { cart_chart.AxisY[0].MaxValue = axes_limit.yhigh; }
            }

            // pseudo axes to display the axes more easily because hiding the axes grids also hides the actual axes edges 
            // hence needed these pseudo axes, which do not affect performance, as far as I know 
            cart_chart.AxisX.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 0.5, Step = 1, Stroke = axes_color },
                MinValue = 0,
                MaxValue = 0.5,
                FontSize = 0.5F,
                Foreground = System.Windows.Media.Brushes.Transparent
            });
            cart_chart.AxisY.Add(new Axis
            {
                Separator = new Separator { StrokeThickness = 0.5, Step = 1, Stroke = axes_color },
                MinValue = 0,
                MaxValue = 0.5,
                FontSize = 0.5F,
                Foreground = System.Windows.Media.Brushes.Transparent
            });

            // Legend location 
            cart_chart.LegendLocation = lgnd_loc;

            // Maximize plot performacne for streaming data, refer to ref. (2) 
            cart_chart.DisableAnimations = true;
            cart_chart.Hoverable = false;
            cart_chart.DataTooltip = null;
            cart_chart.Invalidate();

        }

        #endregion

        #region Helper functions 
        private void ReturnRMSLevel(double value, out Color color_res, out int level_res)
        {
            if (value < APP_INP_PRM.danger_rms_lowerbound | value > APP_INP_PRM.danger_rms_upperbound)
            {
                color_res = APP_INP_PRM.danger_color;
                level_res = 2;
            }
            else if (value < APP_INP_PRM.warning_rms_lowerbound | value > APP_INP_PRM.warning_rms_upperbound)
            {
                color_res = APP_INP_PRM.warning_color;
                level_res = 1;
            }
            else
            {
                color_res = APP_INP_PRM.normal_color;
                level_res = 0;
            }
        }

        private void ReturnLBPLevel(double value, out Color color_res, out int level_res)
        {
            if (value < APP_INP_PRM.danger_lbp_lowerbound | value > APP_INP_PRM.danger_lbp_upperbound)
            {
                color_res = APP_INP_PRM.danger_color;
                level_res = 2;
            }
            else if (value < APP_INP_PRM.warning_lbp_lowerbound | value > APP_INP_PRM.warning_lbp_upperbound)
            {
                color_res = APP_INP_PRM.warning_color;
                level_res = 1;
            }
            else
            {
                color_res = APP_INP_PRM.normal_color;
                level_res = 0;
            }
        }

        private double[] Full_Deep_Copy(double[] source)
        {
            double[] destination = new double[source.Length];
            Array.Copy(source, destination, source.Length);
            return destination;
        }
        #endregion

        #region Update functions for simple WF objects 
        private void UpdateTextBox(TextBox txtbx, string s)
        {
            if (InvokeRequired)
            {
                txtbx.BeginInvoke(new Action<TextBox, string>(UpdateTextBox), new object[] { txtbx, s });
                return;
            }
            txtbx.Text = s;
        }

        private void UpdateLabel(Label lbl, string s)
        {
            if (InvokeRequired)
            {
                lbl.BeginInvoke(new Action<Label, string>(UpdateLabel), new object[] { lbl, s });
                return;
            }
            lbl.Text = s;
        }

        private void UpdatePanelColor(Panel pnl, Color c)
        {
            if (InvokeRequired)
            {
                pnl.BeginInvoke(new Action<Panel, Color>(UpdatePanelColor), new object[] { pnl, c });
                return;
            }
            pnl.Refresh();
            pnl.CreateGraphics().FillRectangle(new SolidBrush(c), 0, 0, pnl.Width, pnl.Height);
        }

        private void UpdateInitialization(string connection_success)
        {
            UpdateTextBox(log, connection_success + "\r\n" + APP_INP_PRM.WelcomeMessage);

            UpdateLabel(chan_label1_rms_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[0]);
            UpdateLabel(chan_label2_rms_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[1]);
            UpdateLabel(chan_label1_spectral_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[0]);
            UpdateLabel(chan_label2_spectral_alarm, "Channel " + APP_INP_PRM.chan_idx2plt[1]);

            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));

        }
        #endregion

        #region Update functions for the plots 
        private void UpdateTimeSeriesPlot(  bool refreshable, 
                                            LiveCharts.WinForms.CartesianChart cart_chart,
                                            GearedValues<ObservablePoint>[] series,
                                            double t,
                                            double[] values,
                                            double[] display_gains, 
                                            double display_sep,
                                            double max_sec_plt,
                                            double max_pnt_plt)
        {
            if (InvokeRequired)
            {
                cart_chart.BeginInvoke(new Action<
                                            bool,
                                            LiveCharts.WinForms.CartesianChart,
                                            GearedValues<ObservablePoint>[],
                                            double,
                                            double[],
                                            double[],
                                            double,
                                            double,
                                            double>(UpdateTimeSeriesPlot),
                                                new object[] {
                                                    refreshable,
                                                    cart_chart,
                                                    series,
                                                    t,
                                                    values,
                                                    display_gains,
                                                    display_sep,
                                                    max_sec_plt,
                                                    max_pnt_plt
                                                    });
                return;
            }

            int n_values = series.Length;
          
            for (int i = 0; i < n_values; i++)
            {
                if (series[i].Count >= max_pnt_plt)
                {
                    if (refreshable) { series[i].Clear(); }
                    else { series[i].RemoveAt(0); }
                }
                series[i].Add(new ObservablePoint(t, values[i] * display_gains[i] - display_sep * i)); 
            }


            if (refreshable)
            {
                RefreshableAxisLimits(t, max_sec_plt, out double min_bound, out double max_bound);
                cart_chart.AxisX[0].MinValue = min_bound;
                cart_chart.AxisX[0].MaxValue = max_bound;
            }

        }

        private void UpdateSTFTPlot()
        {
            for (int ichan = 0; ichan < APP_INP_PRM.nchan; ichan++)
            {
                int n_valid = STFTCalcs[ichan].n_valid;
                STFTSeries[ichan].Clear();
                STFTCalcs[ichan].CalculatePSD();
                ObservablePoint[] stft_new = new ObservablePoint[n_valid];
                double[] freq = new double[n_valid], mag = new double[n_valid];
                
                Array.Copy(STFTCalcs[ichan].freq_vec, 0, freq, 0, n_valid);
                Array.Copy(STFTCalcs[ichan].mag_freq, 0, mag, 0, n_valid);
                for (int idat = 0; idat < n_valid; idat++)
                {
                    stft_new[idat] = new ObservablePoint(freq[idat], mag[idat]);
                }
                STFTSeries[ichan].AddRange(stft_new);
            }
        }

        private void RefreshableAxisLimits(double t, double max_sec_plt, out double min_bound, out double max_bound)
        {
            min_bound = (Math.Floor(t / max_sec_plt) * max_sec_plt);
            max_bound = (Math.Floor(t / max_sec_plt) + 1) * max_sec_plt;
        }

        #endregion

        #region The main action 
        public void DrawAndReport()
        {
            try
            {
                TcpClient client = new TcpClient();
                client.Connect(APP_INP_PRM.hostname, APP_INP_PRM.port);

                UpdateInitialization("Connection successful!"); 

                Byte[] bytes = new Byte[1024];
                int[] chan_idx = { APP_INP_PRM.chan_idx2plt[0], APP_INP_PRM.chan_idx2plt[1] };
                int nchan = APP_INP_PRM.nchan;

                Panel[] rms_alarm_panels = { rms_alarm1, rms_alarm2 };
                Panel[] lbp_alarm_panels = { lbp_alarm1, lbp_alarm2 };

                int stream_read;
                int count = 0;
                Stream stream = client.GetStream();


                string csvFilePath = APP_INP_PRM.output_file_name;
                File.WriteAllText(csvFilePath, "Data_1;RMS_1;RMSLevel_1;Data_2;RMS_2;RMSLevel_2\n");
                while ((stream_read = stream.Read(bytes, 0, bytes.Length)) != 0)
                {
                    string data_with_lines = System.Text.Encoding.ASCII.GetString(bytes, 0, stream_read);
                    string[] lines = data_with_lines.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                    //lines = lines.Where(x => !string.IsNullOrEmpty(x)).ToArray();
                    lines = lines.Where(x => !x[0].Equals(',')).ToArray();
                    lines = lines.Where(x => x.Split(',').Length == APP_INP_PRM.chunk_len).ToArray();
                    if (lines.Length == 0) { continue; }
                    if (lines.Length > 0)
                    {
                        int start_iline, end_iline;
                        if (lines.Length == 1)
                        {
                            start_iline = 0;
                            end_iline = 1;
                        }
                        else
                        {
                            start_iline = 1;
                            end_iline = lines.Length - 1;
                        }
                        for (int i_line = start_iline; i_line < end_iline; i_line++)
                        {
                            string data = lines[i_line];
                            string[] current_data_chunk = data.Split(',');
                            for (int ix = 0; ix < APP_INP_PRM.nsamp_per_block; ix++)
                            {

                                double t = ((double)count) / APP_INP_PRM.Fs;
                                for (int ich = 0; ich < nchan; ich++)
                                {
                                    bool parse_success = RMSCalcs[ich].ParseCurrentValue(current_data_chunk[ix + chan_idx[ich] * APP_INP_PRM.nsamp_per_block]);
                                    if (!parse_success)
                                    {
                                        Console.WriteLine("Warning: Parse unsuccessful with the input below");
                                        Console.WriteLine(data);
                                        break;
                                    }
                                }

                                double[] viz = {    RMSCalcs[0].current_val,
                                                RMSCalcs[1].current_val,
                                                RMSCalcs[0].current_val - RMSCalcs[1].current_val };
                                        
                                UpdateTimeSeriesPlot(
                                    refreshable:    APP_INP_PRM.refresh_display,
                                    cart_chart:     channel_plots,
                                    series:         ChannelSeries,
                                    t:              t,
                                    values:         viz,
                                    display_gains:  APP_INP_PRM.display_channel_vertgains,
                                    display_sep:    APP_INP_PRM.display_channel_vertoffset,
                                    max_sec_plt:    APP_INP_PRM.max_sec_plt,
                                    max_pnt_plt:    APP_INP_PRM.max_pnt_plt);

                                TimeSpan tsp = TimeSpan.FromSeconds(t);

                                Color[] rms_lvl_colors = new Color[nchan];
                                int[] rms_lvls = new int[nchan];
                                double[] current_rms_arr = new double[nchan], current_val_arr = new double[nchan];

                                for (int ich = 0; ich < nchan; ich++)
                                {
                                    RMSCalcs[ich].CalculateRMS(count);
                                    current_rms_arr[ich] = RMSCalcs[ich].current_rms;
                                    current_val_arr[ich] = RMSCalcs[ich].current_val;
                                    ReturnRMSLevel(current_rms_arr[ich], out rms_lvl_colors[ich], out rms_lvls[ich]);
                                    UpdatePanelColor(rms_alarm_panels[ich], rms_lvl_colors[ich]);

                                    RMSCalcs[ich].Tally_Levels(rms_lvls[ich]);
                                }

                                UpdateTimeSeriesPlot(
                                    refreshable:    APP_INP_PRM.refresh_display,
                                    cart_chart:     rms_plots,
                                    series:         RMSSeries,
                                    t:              t,
                                    values:         current_rms_arr,
                                    display_gains:  APP_INP_PRM.display_rms_vertgains,
                                    display_sep:    APP_INP_PRM.display_rms_vertoffset,
                                    max_sec_plt:    APP_INP_PRM.max_sec_plt,
                                    max_pnt_plt:    APP_INP_PRM.max_pnt_plt);


                                for (int ich = 0; ich < nchan; ich++)
                                {
                                    STFTCalcs[ich].CalculateFFT(t, RMSCalcs[ich].current_val);
                                }

                                if (STFTCalcs[0].ready2plt)
                                {
                                    double[] viz_bp = new double[nchan];
                                    double[] pseudo_gains = new double[nchan];
                                    double pseudo_sep = 0;

                                    Color[] lbp_lvl_colors = new Color[nchan];
                                    int[] lbp_lvls = new int[nchan];

                                    for (int ich = 0; ich < nchan; ich++) {
                                        STFTCalcs[ich].CalculatePSD();
                                        viz_bp[ich] = STFTCalcs[ich].band_power;
                                        pseudo_gains[ich] = 1.0;

                                        ReturnLBPLevel(viz_bp[ich], out lbp_lvl_colors[ich], out lbp_lvls[ich]);
                                        UpdatePanelColor(lbp_alarm_panels[ich], lbp_lvl_colors[ich]);

                                        STFTCalcs[ich].Tally_Levels(lbp_lvls[ich]); 
                                    }
                                    spectral_plots.BeginInvoke(new Action(UpdateSTFTPlot));
                                    UpdateTimeSeriesPlot(
                                        refreshable:    APP_INP_PRM.refresh_display, 
                                        cart_chart:     limbandpow_plots,
                                        series:         LBPSeries,
                                        t:              t,
                                        values:         viz_bp,
                                        display_gains:  pseudo_gains,
                                        display_sep:    pseudo_sep, 
                                        max_sec_plt:    APP_INP_PRM.max_sec_plt,
                                        max_pnt_plt:    APP_INP_PRM.max_pnt_plt);

                                }

                                if (count % APP_INP_PRM.rms_lvl_reset_point == 0 && count > 0)
                                {
                                    int n_lvls = RMSCalcs[0].n_lvls;
                                    double[] rms_lvl_arrs = new double[n_lvls];
                                    double[] pseudo_gains = new double[n_lvls];
                                    double pseudo_sep = 0;

                                    if (APP_INP_PRM.alarm_rate_plt_stack)
                                    {
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            RMSCalcs[ich].Cumulative_From_Lower_Level();
                                        }
                                    }
                                    for (int ilvl = 0; ilvl < n_lvls; ilvl++)
                                    {
                                        pseudo_gains[ilvl] = 1.0;
                                        rms_lvl_arrs[ilvl] = 0;
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            rms_lvl_arrs[ilvl] += RMSCalcs[ich].rms_levels[ilvl];
                                        }
                                    }
                                    UpdateTimeSeriesPlot(
                                        refreshable:    false, 
                                        cart_chart:     rms_alarm_plots,
                                        series:         RMSAlarmSeries,
                                        t:              t,
                                        values:         rms_lvl_arrs,
                                        display_gains:  pseudo_gains,
                                        display_sep:    pseudo_sep,
                                        max_sec_plt:    APP_INP_PRM.rms_lvl_max_sec,
                                        max_pnt_plt:    APP_INP_PRM.rms_lvl_max_point);
                                 
                                    for (int ich = 0; ich < nchan; ich++)
                                    {
                                        RMSCalcs[ich].Reset_Level_Tally();
                                    }


                                }

                                if (count % APP_INP_PRM.lbp_lvl_reset_point == 0 && count > 0)
                                {
                                    int n_lvls = STFTCalcs[0].n_lvls;
                                    double[] lbp_lvl_arrs = new double[n_lvls];
                                    double[] pseudo_gains = new double[n_lvls];
                                    double pseudo_sep = 0;

                                    if (APP_INP_PRM.alarm_rate_plt_stack)
                                    {
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            STFTCalcs[ich].Cumulative_From_Lower_Level();
                                        }
                                    }
                                    for (int ilvl = 0; ilvl < n_lvls; ilvl++)
                                    {
                                        pseudo_gains[ilvl] = 1.0;
                                        lbp_lvl_arrs[ilvl] = 0;
                                        for (int ich = 0; ich < nchan; ich++)
                                        {
                                            lbp_lvl_arrs[ilvl] += STFTCalcs[ich].lbp_levels[ilvl];
                                        }
                                    }
                                    UpdateTimeSeriesPlot(
                                        refreshable:    false,
                                        cart_chart:     lbp_alarm_plots,
                                        series:         LBPAlarmSeries,
                                        t:              t,
                                        values:         lbp_lvl_arrs,
                                        display_gains:  pseudo_gains,
                                        display_sep:    pseudo_sep,
                                        max_sec_plt:    APP_INP_PRM.lbp_lvl_max_sec,
                                        max_pnt_plt:    APP_INP_PRM.lbp_lvl_max_point);
                                    for (int ich = 0; ich < nchan; ich++)
                                    {
                                        STFTCalcs[ich].Reset_Level_Tally();
                                    }


                                }

                                UpdateLabel(clock, tsp.ToString(@"hh\:mm\:ss\:fff"));

                                string nextLine = string.Format("{0};{1};{2};{3};{4};{5}\n",
                                    current_val_arr[0], current_rms_arr[0], rms_lvls[0],
                                    current_val_arr[1], current_rms_arr[1], rms_lvls[1]);
                                File.AppendAllText(csvFilePath, nextLine);

                                count++;
                            }
                        }
                    }
                }
                client.Close();

            }
            catch (Exception e)
            {
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                Console.WriteLine("!!!!\t" + e.StackTrace);
                DrawAndReport();
            }
        }
        #endregion

        #region Events of Control Objects 

        private void exit_button_Click(object sender, EventArgs e)
        {
            Application.Exit();
            Environment.Exit(1);
        }


        #region Channel gain and separation control for display 
        private void changain_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Gain(1);
            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }


        private void changain_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Gain(-1);
            UpdateLabel(chan_vertgain_val, string.Join("; ", APP_INP_PRM.display_channel_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }


        private void chansep_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Separation(1);
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
        }

        private void chansep_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_Channel_Separation(-1);
            UpdateLabel(chan_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_channel_vertoffset));
        }
        #endregion
        #region RMS gain and separation control for display 
        private void rmsgain_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Gain(1);
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }

        private void rmsgain_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Gain(-1);
            UpdateLabel(rms_vertgain_val, string.Join("; ", APP_INP_PRM.display_rms_vertgains.Select(p => string.Format("{0:0.00}", p)).ToArray()));
        }

        private void rmssep_up_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Separation(1);
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));
        }

        private void rmssep_down_Click(object sender, EventArgs e)
        {
            APP_INP_PRM.Control_RMS_Separation(-1);
            UpdateLabel(rms_vertoffset_val, string.Format("{0:0.00}", APP_INP_PRM.display_rms_vertoffset));
        }
        #endregion

        #endregion


    }
}
