using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net.Sockets;

// Tuan added _ begin 
using OxyPlot;
using OxyPlot.WindowsForms;
using OxyPlot.Axes;
using OxyPlot.Series;
using System.Collections;
using System.Collections.Generic;
// Tuan added _ end 

// Seizure Filter EEG Program 
// Started by Dominic DiCarlo September 2018

// This program requires communication with OpenViBE acquisition software
// as well as designer software. That software can be obtained from
// Brain Products, and is found on the flash drive Towle lab
// received from them.

// What this program does:
//
// This program reads in data from a TCP server generated by OpenViBE Designer 
// It takes in the data given at 512 Hz signal delivered in 4 sample chunks 
// (or a 128 Hz signal delivering 4 samples at a time) and calculates
// the RMS to (theoretically) predict when a seizure might be coming on.
// if the RMS approaches certain upper or lower bounds, the graphical interface
// of the program will change the color of a bar to signify this, from green (safe)
// to yellow (caution), to red (danger). Right now, the upper and lower bounds of
// these ranges has been arbitrarily decided. To use this program for the
// visual prosthesis, these values will either have to be pre-determined
// or determined after experimentation has begun. We must decide whether to
// err on the side of safety or risk. 

// How to Run the program:
// 1) Connect the V-Amplifier to the computer and install any drivers
//    you may be prompted to. The Brain Products usb will also install some drivers
//    to your PC; these are needed for the V-Amp (supposedly)
//
// 2) Open OpenViBE Acquisition Server. Select V-Amp/Fast Amp from the Driver drop
//    down menu. Adjust drift tolerance to 2.00 ms or lower from the Preferences button.
//    Set "Sample count per sent block" to 4.
//
// 3) Open OpenViBE Designer. If this is your first time, select
//    an "Acquisition Client" box from the folder "Acquisition and network IO".
//    connect this to a "Temporal filter" box from '"Signal Processing"->"Temporal Filtering"'.
//    Connect the "Temporal filter" box to a "Signal display" box and a "Matrix sender" box.
//
//    IMPORTANT: Assure the "Matrix sender" box has TCP port "1234". You can check this by
//    double clicking it, and seeing the TCP port. 
//
//    EQUALLY IMPORANT: Assure the "Acquisition client" box has the same acquisition server
//    port as the Connection port number on OpenViBE Acquisition Server. You can check the box
//    by double clicking it, and the actual Acquisition Server right on the front of the program
//
//    All the program really needs from designer is the "Matrix Sender", as this is what it reads.
//    Feel free to adjust the Temporal Filter to your exact frequency needs,
//    as well as adjust the signal display parameters for your needs. 
//
//    You can save your settings in OpenViBE Designer as a config file. Simply
//    click Save As at the top or Save. 
//
// 4) Hit Start at the top of Visual Studio, or run this program in the packaged way
//    you have decided. Then, hit the play arrow on top of OpenViBE designer. 
//    Voila! The program should be running. If not, run through these steps again
//    and ensure you have done everything right.


// Some things to consider integrating:
//
// 1) It would be nice to be able to change the upper and lower bounds of the RMS
//    safety window from the GUI. This change could be easily made
//
// 2) Adding more channels and the ability to manage multiple samples from the stream
//    at once.
//    - There is room in the logic to do this, and it would just look like more
//      of the same code. We would need to decide how many channels we want to 
//      look at in the first place.
//
// 3) Adding in EEG visualization
//      - OpenViBE supplies this in the mean time, but creating our own EEG viewer
//        would be optimal as we can modify it to suit our needs.
//
// 4) Some visualization of the RMS over time
//      - This would be very useful, as right now we only get monitoring of the present
//        state of the RMS, and we might want to look at the trends it is taking.
//
// 5) Writing the CSV of values from the experiment in a path that will work for
//    all systems
//      - Right now, the CSV path has to be edited in the code
//        so that it works on other systems. What would be more ideal
//        would be the user selecting a path before the program begins. 
//        This would be easy to program. 

// The logic of everything is simplified right now to only work with one
// channel and one sample at a time. This is then a skeleton for more work
// depending on how much data you want to use. 

namespace WindowsFormsApp4
{
    public partial class Form1 : Form
    {
        // these are the publically defined range values
        // for the RMS. The Red range is for absolute danger
        // while the Yellow (ylw) range is for caution.
        public double redRangeRmsUp = 1.4;
        public double redRangeRmsLow = 0.6;
        public double ylwRangeRmsUp = 1.2;
        public double ylwRangeRmsLow = 0.8;

        //**
        // Tuan added _ start 
        public LineSeries rms_lineseries;
        public PlotView myRMSPlot;
        public PlotModel myRMSModel;

        private Thread plot_thread;
        // Tuan added _ end 
        //**/ 

        private Thread logic_thread;
        // private Thread form_thread;
        public Form1()
        {
            InitializeComponent();
            this.Load += Form1_Load;
            //** Tuan added _ start
            init_RMSplot(); 
            // Tuan added _ end 
            //**/


        }

        private void Form1_Load(object sender, EventArgs e)
        {
            logic_thread = new Thread(drawAndReport);
            logic_thread.Start();
        }
        
        
        /** Tuan cmnt out 
        private void Form1_newForm(object sender, EventArgs e)
        {
            form_thread = new Thread(form2);
            form_thread.Start();
        }
     
        public void form2()
        {

        }
        **/ 

        // Tuan added _ begin : implementation mirroring 'drae RMS'
        private void init_RMSplot()
        {
            myRMSPlot = new PlotView
            {
                Dock = System.Windows.Forms.DockStyle.Bottom,
                Location = new System.Drawing.Point(500, 500),
                Size = new System.Drawing.Size(500, 500),
                TabIndex = 1
            };

            myRMSModel = new PlotModel
            {
                Title = "RMS plot",
                PlotType = PlotType.Cartesian,
                Background = OxyColors.White
            };

            var linearAxisX = new LinearAxis
            {
                Title = "Count #",
                Position = AxisPosition.Bottom
            };
            myRMSModel.Axes.Add(linearAxisX);

            var linearAxisY = new LinearAxis
            {
                Title = "RMS values",
                Position = AxisPosition.Left
            };
            myRMSModel.Axes.Add(linearAxisY);

            this.rms_lineseries = new LineSeries
            {
                Color = OxyColors.Black,
                MarkerStroke = OxyColors.Black,
                MarkerType = MarkerType.Circle,
                StrokeThickness = 1.5,
                LineStyle = LineStyle.Solid
            };
            myRMSModel.Series.Add(this.rms_lineseries);

            myRMSPlot.Model = myRMSModel;
            Controls.Add(myRMSPlot);
        }

        public void drawAndReport()
        {
            /**
             * Need to address magic numbers and organize then better
            */ 
            
            try 
            { 
                TcpClient client = new TcpClient();
                client.Connect("127.0.0.1", 1234);
                int ntotal_samp = 64;
                int nsamp_per_block = 7;
                int num_channel = -1;  // meaning has not been defined 
                int chan_idx2plt = 0; 
                log.Invoke(new Action(() =>
                {
                    log.Text = "Connected!";
                }));

                Byte[] bytes = new Byte[16384];
                Queue<double> data_queue = new Queue<double>();
                double oldest_val = 0, newest_val = 0; 

                while (true) {
                    int stream_read;
                    int count = 0;
                    double current_rms_sq = 0;
                    double current_rms = 0;
                    Stream stream = client.GetStream();

                    string csvFilePath = @"C:\Users\Towle\Desktop\testfile_TP.csv";
                    File.WriteAllText(csvFilePath, "");

                    while ((stream_read = stream.Read(bytes, 0, bytes.Length)) != 0) {
                        string data = System.Text.Encoding.ASCII.GetString(bytes, 0, stream_read);
                        log.Invoke(new Action(() => {
                            log.Text = data;
                        }));

                        string[] niceData = data.Split(',');
                        if (num_channel < 0) {
                            num_channel = (int)niceData.Length / nsamp_per_block;
                            Console.WriteLine("Number of channels = " + num_channel);
                            
                        }
                        double niceData_ix = 0;
                        for (int ix = 0; ix < nsamp_per_block; ix++) {
                            // This was somehow downsampled 
                            // need to take a look at 
                            // maybe the time it took to get thru each loop interfered with the timing 
                            // dont know yet how to solve this
                            // maybe it's best to read from the file output of signal display instead? 
                            double.TryParse(niceData[chan_idx2plt * ix + num_channel], out niceData_ix);
                            /*
                            data_queue.Enqueue(niceData_ix);

                            if (count < ntotal_samp) {
                                current_rms_sq += niceData_ix * niceData_ix;
                            }
                            else if (count == ntotal_samp) {
                                current_rms = Math.Sqrt(current_rms_sq / ntotal_samp);
                            }
                            else {
                                oldest_val = data_queue.Dequeue();
                                oldest_val = oldest_val * oldest_val / ntotal_samp;

                                newest_val = niceData_ix * niceData_ix / ntotal_samp;
                                current_rms = Math.Sqrt(current_rms - oldest_val + newest_val);
                            }

                            this.rms_lineseries.Points.Add(new DataPoint((double)count, niceData_ix));
                            myRMSPlot.InvalidatePlot(true);
                            myRMSModel.DefaultXAxis.Reset();
                            myRMSModel.DefaultYAxis.AbsoluteMinimum = -5;
                            myRMSModel.DefaultYAxis.AbsoluteMaximum = 5;
                            
                            rms_val.Invoke(new Action(() => {
                                rms_val.Text = String.Format("{0}", current_rms);
                            }));

                            if (current_rms < redRangeRmsLow | current_rms > redRangeRmsUp) {
                                panel1.BackColor = Color.FromArgb(255, 0, 0);
                            }
                            else if (current_rms < ylwRangeRmsLow | current_rms > ylwRangeRmsUp) {
                                panel1.BackColor = Color.FromArgb(255, 255, 0);
                            }
                            else {
                                panel1.BackColor = Color.FromArgb(0, 255, 0);
                            }
                            */

                            string nextLine = string.Format("{0}\n", niceData_ix);
                            File.AppendAllText(csvFilePath, nextLine);

                            count++;
                        }
                    }
                    client.Close();
                }
            }
            catch (Exception e)
            {
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                drawAndReport();
            }
        }
        // Tuan added _ end 
        
        public void drawRMS()
        {
           
            
            try
            {
                TcpClient client = new TcpClient();


                // ip addess should be local host, TCP port is as specified in
                // Open Vibe program.
                client.Connect("127.0.0.1", 1234);
                // this log.invoke is the method used to edit the text
                // boxes in the windows form
                log.Invoke(new Action(() =>
                {
                    log.Text = "Connected!";
                }));
       
                // Buffer for reading data
                // Data comes in as ASCII string of comma separated values
                Byte[] bytes = new Byte[16384];

                // this array stores the values in a 500 ms interval to perform root 
                // mean square analysis
                // 64 values represents 500 ms. Because we have a 512 Hz signal from
                // the V-Amp, and we receive a chunk every 4 samples --> 512 / 4 = 128. 
                // 128 samples per second --> 64 samples per 1/2 second, or 500 ms.
                uint maxSamplesStored = 64;

                // we use 4 arrays so we can calculate every 16 values, or in a 125 ms interval
                // In other words, every 125 ms we need to be able to pull up
                // the last 500 ms worth of values. So every 16 values we need to pull up 
                // the last 64 values. So each of these arrays is separated from the next by 
                // 16 values.
                Double[] storedValues1 = new Double[maxSamplesStored];
                Double[] storedValues2 = new Double[maxSamplesStored];
                Double[] storedValues3 = new Double[maxSamplesStored];
                Double[] storedValues4 = new Double[maxSamplesStored];

                // this array will
                // be used in the calculation step (changes every 16 values)
                Double[] calcValues = new Double[maxSamplesStored];

                // initiating the double for the channel sample values
                // can initialize more channels and samples
                double channel1Sample1 = 0;
                // double channel1Sample2 = 0; // EX: more channels/samples

                // Enter the listening loop.
                while (true)
                {
                    int i;
                    int count = 0;
                    // this is how many samples are read before the program is auto shut down.
                    // 3840 is roughly 30 seconds
                    Stream stream = client.GetStream();

                    // build csv file
                    // need to customize where to save the text. possibly with user input
                    string csvFilePath = @"C:\Users\Towle\Desktop\testfile.csv";
                    File.WriteAllText(csvFilePath, "");

                    // stream so long as there is something to stream, or until the limit 
                    // number of samples have been collected.
                    while ((i = stream.Read(bytes, 0, bytes.Length)) != 0)
                        {   
                            string data = System.Text.Encoding.ASCII.GetString(bytes, 0, i);
                            log.Invoke(new Action(() =>
                            {
                                //log.Text = String.Format("Channel 1, Sample 1: {0} 
                                // Channel 2, Sample 1: {0}", channel1Sample1); // , channel2Sample1);
                                log.Text = data; // , channel2Sample1);

                            }));
                            // the format of this string array is all the channels for sample 1, 
                            // all the channels for sample 2, ... all
                            // the channels for sample N, for a stream with N channels. 
                            // we are taking the one, long data string and separating it into 
                            // its components
                            string[] niceData = data.Split(',');
                            double.TryParse(niceData[0], out channel1Sample1);

                            // EX: More channels / samples
                            // double channel2Sample1 = double.Parse(niceData[1]);


                            // EX: displaying channel 1 sample 1 to the box everytime 
                            // log.Invoke(new Action(() =>
                            // {
                            //     log.Text = String.Format("Channel 1, Sample 1: {0}", 
                                        // channel1Sample1); // , channel2Sample1);
                            //
                            // }));
                            // 

                            // calculate current array slot for the four different arrays
                            // each array is 16 slots ahead of the next in terms
                            // of the data stream. this is why 16 is subtracted from the first
                            // to make the second, and another 16 from the second for the third, etc.
                            int currentSlotArray1 = count % 64;
                            int currentSlotArray2 = (count - 16) % 64;
                            int currentSlotArray3 = (count - 32) % 64;
                            int currentSlotArray4 = (count - 48) % 64;

                            // we don't want to start calculating until we have at least 64 values,
                            // so we don't negatively index any arrays.
                            if (count > 63)
                            {
                                storedValues1[currentSlotArray1] = channel1Sample1;
                                storedValues2[currentSlotArray2] = channel1Sample1;
                                storedValues3[currentSlotArray3] = channel1Sample1;
                                storedValues4[currentSlotArray4] = channel1Sample1;
                            }
                            // proceed to calculation step
                            // perform a calculation every 16th iteration 
                            if (count > 63 && ((currentSlotArray1 + 1) % 16 == 0)) 
                            
                            {
                                switch (currentSlotArray1 + 1)
                                {
                                    case 16:
                                        calcValues = storedValues1;
                                        break;
                                    case 32:
                                        calcValues = storedValues2;
                                        break;
                                    case 48:
                                        calcValues = storedValues3;
                                        break;
                                    case 64:
                                        calcValues = storedValues4;
                                        break;
                                }
                                                                 
                                // run a calculation
                                double rms1 = 0;
                                // taking the sum of normalized squares
                                foreach (double v in calcValues)
                                {
                                    rms1 += (v * v);
                                }
                                // taking the square root of that sum
                                rms1 = Math.Sqrt(rms1 / calcValues.Length);
                                // display result
                                rms_val.Invoke(new Action(() =>
                                {
                                    rms_val.Text = String.Format("{0}", rms1);

                                }));
                                // color step
                                if (rms1 < redRangeRmsLow | rms1 > redRangeRmsUp) // red - danger
                                {
                                    panel1.BackColor = Color.FromArgb(255, 0, 0);
                                }
                                else if (rms1 < ylwRangeRmsLow | rms1 > ylwRangeRmsUp) // yellow - caution
                                {
                                    panel1.BackColor = Color.FromArgb(255, 255, 0);
                                }
                                else // green - safe
                                {
                                    panel1.BackColor = Color.FromArgb(0, 255, 0);
                                }

                            //**
                            // Tuan added _ start 
                            
                                this.rms_lineseries.Points.Add(new DataPoint( (double)count, rms1));
                                myRMSPlot.InvalidatePlot(true);
                                myRMSModel.DefaultXAxis.Reset(); 
                                myRMSModel.DefaultYAxis.AbsoluteMinimum = 0.85;
                                myRMSModel.DefaultYAxis.AbsoluteMaximum = 1.15;
                            // Tuan added _ end 
                            //**/
                        }
                              
                            
                                // format the lines for the csv file
                                string nextLine = string.Format("{0}\n", channel1Sample1);

                                // append lines to csv file
                                File.AppendAllText(csvFilePath, nextLine);
                                count++;
                        }
                    // this code should technically never be reached    
                    client.Close();
                }
            }

            // this is reached if we have trouble connecting with the client. 
            // it calls on the function again in case the connection error
            // is just a small hitch to prevent having to restart the program.
            catch (Exception e)
            {
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                drawRMS();
            }
        }
    }
}
