using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;
using System.Net.Sockets;
using System.Collections.Generic;

using LiveCharts;
using LiveCharts.Wpf; 
using LiveCharts.Configurations;
using LiveCharts.Defaults;

/** SEIZURE FILTER EEG PROGRAM
 * Started by Dominic DiCarlo September 2018

    + REQUIREMENTS: 

            This program requires communication with OpenViBE acquisition software
        as well as designer software.That software can be obtained from
        Brain Products, and is found on the flash drive Towle lab
        received from them.

    + SUMMARY OF PURPOSE:
    
            This program reads in data from a TCP server generated by OpenViBE Designer
        It takes in the data given at 512 Hz signal delivered in 4 sample chunks
        (or a 128 Hz signal delivering 4 samples at a time) and calculates
        the RMS to(theoretically) predict when a seizure might be coming on.

            If the RMS approaches certain upper or lower bounds, the graphical interface
        of the program will change the color of a bar to signify this, from green (safe)
        to yellow (caution), to red (danger). Right now, the upper and lower bounds of
        these ranges has been arbitrarily decided. To use this program for the
        visual prosthesis, these values will either have to be pre-determined
        or determined after experimentation has begun.We must decide whether to
        err on the side of safety or risk.

    + EXECUTION: 
        1)  Connect the V-Amplifier to the computer and install any drivers
            you may be prompted to. The Brain Products usb will also install some drivers
            to your PC; these are needed for the V-Amp (supposedly)

        2)  Open OpenViBE Acquisition Server. Select V-Amp/Fast Amp from the Driver drop
            down menu. Adjust drift tolerance to 2.00 ms or lower from the Preferences button.
            Set "Sample count per sent block" to 4.

        3)  Open OpenViBE Designer. If this is your first time, select
            an "Acquisition Client" box from the folder "Acquisition and network IO".
            connect this to a "Temporal filter" box from '"Signal Processing"->"Temporal Filtering"'.
            Connect the "Temporal filter" box to a "Signal display" box and a "Matrix sender" box.

            NOTE #1 : Assure the "Matrix sender" box has TCP port "1234". You can check this by
            double clicking it, and seeing the TCP port. 

            NOTE #2: Assure the "Acquisition client" box has the same acquisition server
            port as the Connection port number on OpenViBE Acquisition Server. You can check the box
            by double clicking it, and the actual Acquisition Server right on the front of the program

            All the program really needs from designer is the "Matrix Sender", as this is what it reads.
            Feel free to adjust the Temporal Filter to your exact frequency needs,
            as well as adjust the signal display parameters for your needs. 

            You can save your settings in OpenViBE Designer as a config file. Simply
            click Save As at the top or Save. 

        4)  Hit Start at the top of Visual Studio, or run this program in the packaged way
            you have decided. Then, hit the play arrow on top of OpenViBE designer. 
            Voila! The program should be running. If not, run through these steps again
            and ensure you have done everything right.


    + FUTURE CONSIDERTIONS:

        1)  It would be nice to be able to change the upper and lower bounds of the RMS
            safety window from the GUI. This change could be easily made

        2)  Adding more channels and the ability to manage multiple samples from the stream at once.
            - There is room in the logic to do this, and it would just look like more of the same code. 
            We would need to decide how many channels we want to look at in the first place.

        3)  Adding in EEG visualization
            - OpenViBE supplies this in the mean time, but creating our own EEG viewer
            would be optimal as we can modify it to suit our needs.

        4)  Some visualization of the RMS over time
            - This would be very useful, as right now we only get monitoring of the present
            state of the RMS, and we might want to look at the trends it is taking.

        5)  Writing the CSV of values from the experiment in a path that will work for all systems
            - Right now, the CSV path has to be edited in the code
            so that it works on other systems.What would be more ideal
            would be the user selecting a path before the program begins.
            This would be easy to program.

    The logic of everything is simplified right now to only work with one
    channel and one sample at a time.This is then a skeleton for more work
    depending on how much data you want to use.
*/

namespace WindowsFormsApp4
{
    public partial class Form1 : Form
    {
        private AppInputParameters app_inp_prm; 
        private Thread logic_thread;
        public ChartValues<ObservablePoint>[] Obs { get; set; }

        public Form1()
        {
            InitializeComponent();

            using (Prompt prompt = new Prompt("ENTER THE INPUT PARAMETERS", "Input parameters"))
            {
                app_inp_prm = prompt.Result;
            }

            initializePlot();             
            this.Load += Form1_Load;
        }

        private void initializePlot()
        {
            var mapper = Mappers.Xy<ObservablePoint>()
                            .X(value => value.X)
                            .Y(value => value.Y);
            Charting.For<ObservablePoint>(mapper);

            Obs = new ChartValues<ObservablePoint>[3];
            System.Windows.Media.Brushes[] colors = new System.Windows.Media.Brushes[3];

            for (int idx_obs = 0; idx_obs < 3; idx_obs++)
            {
                Obs[idx_obs] = new ChartValues<ObservablePoint>();
                cartesianChart1.Series.Add(new LineSeries
                {
                    Values = Obs[idx_obs],
                    StrokeThickness = 1,
                    PointGeometry = DefaultGeometries.None,
                    LineSmoothness = 0,
                    Fill = System.Windows.Media.Brushes.Transparent,
                    
                });
            }
            cartesianChart1.DisableAnimations = true; // for performance 
            cartesianChart1.Hoverable = false;
            cartesianChart1.DataTooltip = null;
        }
        private void Form1_Load(object sender, EventArgs e)
        {
            logic_thread = new Thread(drawAndReport);
            logic_thread.Start();
        }       
        
        public void return_indicated_color(double value, out Color color_res, out int level_res)
        {
            if (value < app_inp_prm.danger_lowerbound | value > app_inp_prm.danger_upperbound) {
                color_res = app_inp_prm.danger_color;
                level_res = 2;
            } else if (value < app_inp_prm.warning_lowerbound | value > app_inp_prm.warning_upperbound) {
                color_res = app_inp_prm.warning_color;
                level_res = 1;
            } else {
                color_res = app_inp_prm.normal_color;
                level_res = 0;
            }
        }

        private string welcomeMessage()
        {
            string message = String.Format("Connected to HOST@{0} - PORT@{1}\r\n",
                        this.app_inp_prm.hostname, this.app_inp_prm.port);
            message += "\t+ Sampling frequency: " + this.app_inp_prm.Fs + "\r\n";
            message += "\t+ Number of samples/epoch:" + this.app_inp_prm.nsamp_per_block + "\r\n";
            message += "\t+ Channel to plot: #" + this.app_inp_prm.chan_idx2plt + "\r\n";
            message += String.Format("\t+ RMS window is: {0} points ({1:0} ms)\r\n",
                       this.app_inp_prm.nmax_queue_total, this.app_inp_prm.nmax_queue_total * 1000 / this.app_inp_prm.Fs); 

            return message; 
        }
        
        public void drawAndReport()
        {
            try 
            {
                TcpClient client = new TcpClient();
                client.Connect(this.app_inp_prm.hostname, app_inp_prm.port);
                log.Invoke(new Action(() =>
                {
                    log.Text = welcomeMessage();
                }));

                Byte[] bytes = new Byte[16384];
                Queue<double> data_queue_1 = new Queue<double>();
                Queue<double> data_queue_2 = new Queue<double>();

                double oldest_val_1 = 0, newest_val_1 = 0, oldest_val_2 = 0, newest_val_2 = 0;
                double current_rms_sq_1 = 0, current_rms_sq_2 = 0;
                double current_rms_1 = -1, current_rms_2 = -1; // not initiated 
                
                while (true)
                {
                    int stream_read;
                    int count = 0;
                    Stream stream = client.GetStream();

                    string csvFilePath = this.app_inp_prm.output_file_name;
                    File.WriteAllText(csvFilePath, "Data_1;RMS_1;Level_1;Data_2;RMS_2;Level_2\n");

                    while ((stream_read = stream.Read(bytes, 0, bytes.Length)) != 0)
                    {
                        string data = System.Text.Encoding.ASCII.GetString(bytes, 0, stream_read);
                        string[] current_data_chunk = data.Split(',');              

                        for (int ix = 0; ix < app_inp_prm.nsamp_per_block; ix++)
                        {
                            int idx_chan_samp_1, idx_chan_samp_2;
                            double current_data_point_1, current_data_point_2;
                            double t;                            

                            idx_chan_samp_1 = ix + app_inp_prm.chan_idx2plt * app_inp_prm.nsamp_per_block;
                            double.TryParse(current_data_chunk[idx_chan_samp_1], out current_data_point_1);

                            idx_chan_samp_2 = ix + 1 * app_inp_prm.nsamp_per_block;
                            double.TryParse(current_data_chunk[idx_chan_samp_2], out current_data_point_2);

                            t = ((double)count) / this.app_inp_prm.Fs;
                            cartesianChart1.BeginInvoke(new Action(() => {

                                Obs[0].Add(new ObservablePoint(t, current_data_point_1));
                                if (Obs[0].Count > this.app_inp_prm.max_pnt_plt)
                                {
                                    Obs[0].RemoveAt(0);
                                }
                                
                                Obs[1].Add(new ObservablePoint(t, current_data_point_2-5));
                                if (Obs[1].Count > this.app_inp_prm.max_pnt_plt)
                                {
                                    Obs[1].RemoveAt(0);
                                }

                                Obs[2].Add(new ObservablePoint(t, current_data_point_1 - current_data_point_2 - 10));
                                if (Obs[2].Count > this.app_inp_prm.max_pnt_plt)
                                {
                                    Obs[2].RemoveAt(0);
                                }
                                
                                if (Obs[0].Count > this.app_inp_prm.max_pnt_plt / 2)
                                {
                                    cartesianChart1.AxisY[0].MinValue = -12;
                                    cartesianChart1.AxisY[0].MaxValue = 3;

                                    cartesianChart1.AxisX[0].MinValue = t - 3;
                                    cartesianChart1.AxisX[0].MaxValue = t + 0.1;
                                }

                            }));
                            // queue data and calc rms 
                            data_queue_1.Enqueue(current_data_point_1);
                            
                            if (count < app_inp_prm.nmax_queue_total - 1)
                            {
                                current_rms_sq_1 += current_data_point_1 * current_data_point_1;
                            }
                            else if (count == app_inp_prm.nmax_queue_total - 1)
                            {
                                current_rms_1 = Math.Sqrt(current_rms_sq_1 / app_inp_prm.nmax_queue_total);
                            }
                            else
                            {
                                oldest_val_1 = data_queue_1.Dequeue();                                
                                oldest_val_1 = oldest_val_1 * oldest_val_1 / app_inp_prm.nmax_queue_total;
                                newest_val_1 = current_data_point_1 * current_data_point_1 / app_inp_prm.nmax_queue_total;
                                current_rms_sq_1 = current_rms_1 * current_rms_1; 
                                current_rms_1 = Math.Sqrt(current_rms_sq_1 - oldest_val_1 + newest_val_1);
                            }
                            

                            data_queue_2.Enqueue(current_data_point_2);
                            
                            if (count < app_inp_prm.nmax_queue_total - 1)
                            {
                                current_rms_sq_2 += current_data_point_2 * current_data_point_2;
                            }
                            else if (count == app_inp_prm.nmax_queue_total - 1)
                            {
                                current_rms_2 = Math.Sqrt(current_rms_sq_2 / app_inp_prm.nmax_queue_total);
                            }
                            else
                            {
                                oldest_val_2 = data_queue_2.Dequeue();
                                oldest_val_2 = oldest_val_2 * oldest_val_2 / app_inp_prm.nmax_queue_total;
                                newest_val_2 = current_data_point_2 * current_data_point_2 / app_inp_prm.nmax_queue_total;
                                current_rms_sq_2 = current_rms_2 * current_rms_2;
                                current_rms_2 = Math.Sqrt(current_rms_sq_2 - oldest_val_2 + newest_val_2);
                            }
                            
                            
                            Color color_level_1, color_level_2;
                            int level_idx_1, level_idx_2;
                            return_indicated_color(current_rms_1, out color_level_1, out level_idx_1);
                            panel1.BackColor = color_level_1;

                            return_indicated_color(current_rms_2, out color_level_2, out level_idx_2);

                            // rms_val : will be a certain delay 
                            // consider to rid of 

                            rms_val.BeginInvoke(new Action(() => {
                                rms_val.Text = String.Format("{0}", current_rms_1);
                            }));
                            
                            string nextLine = string.Format("{0};{1};{2};{3};{4};{5}\n", 
                                current_data_point_1, current_rms_1, level_idx_1,
                                current_data_point_2, current_rms_2, level_idx_2);
                            File.AppendAllText(csvFilePath, nextLine);
                            
                            count++;
                        }
                    }
                    client.Close();

                }
            }
            catch (Exception e)
            {
                log.Invoke(new Action(() =>
                {
                    log.Text += "Error..... " + e.StackTrace;
                }));
                Console.WriteLine("!!!!\t" + e.StackTrace);
                drawAndReport();
            }
        }


    }
}
